<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>笑松小站</title>
  
  <subtitle>写我喜欢 读我所爱</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.gitee.io/"/>
  <updated>2022-01-26T06:43:29.953Z</updated>
  <id>https://blog.gitee.io/</id>
  
  <author>
    <name>peachyy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySql SSL CA证书JDBC配置</title>
    <link href="https://blog.gitee.io/2022/01/26/mysql-ssl-ca-jdbc/"/>
    <id>https://blog.gitee.io/2022/01/26/mysql-ssl-ca-jdbc/</id>
    <published>2022-01-25T16:00:00.000Z</published>
    <updated>2022-01-26T06:43:29.953Z</updated>
    
    <content type="html"><![CDATA[<p>开启MySql数据库SSL证书以后 如何在<code>jdbc</code>中配置证书访问呢？<br>关于数据库如何配置SSL证书自行百度  这里演示客户端如何利用证书来进行数据通讯。<br>开启证书jdbc认证后 肯定是有一定的性能开销的，个人觉得内网环境无需配置CA证书校验。</p><p>下面用一个示例来演示如何配置</p><p>未配置证书访问前</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/sslcatestdb?zeroDateTimeBehavior=convertToNull&amp;characterEncoding=utf-8</span></span><br></pre></td></tr></table></figure><p>配置了证书访问后</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/sslcatestdb?zeroDateTimeBehavior=convertToNull&amp;characterEncoding=utf-8useSSL=true&amp;trustCertificateKeyStoreUrl=file:/证书路径&amp;trustCertificateKeyStoreType=证书类型&amp;trustCertificateKeyStorePassword=证书密码&amp;</span></span><br><span class="line">clientCertificateKeyStoreUrl=file:/证书路径&amp;clientCertificateKeyStoreType=证书类型&amp;clientCertificateKeyStorePassword=证书密码&amp;verifyServerCertificate=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>证书相关配置属性</p><ul><li>useSSL  开启ssl</li><li>trustCertificateKeyStoreUrl    服务端证书路径</li><li>trustCertificateKeyStoreType  服务端证书类型</li><li>trustCertificateKeyStorePassword  服务端证书密码</li><li>clientCertificateKeyStoreUrl  客户端证书路径</li><li>clientCertificateKeyStoreType  客户端证书类型 </li><li>clientCertificateKeyStorePassword 客户端证书密码</li><li>verifyServerCertificate 信任验证服务器证书</li></ul><p>参考 <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-security.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-security.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开启MySql数据库SSL证书以后 如何在&lt;code&gt;jdbc&lt;/code&gt;中配置证书访问呢？&lt;br&gt;关于数据库如何配置SSL证书自行百度  这里演示客户端如何利用证书来进行数据通讯。&lt;br&gt;开启证书jdbc认证后 肯定是有一定的性能开销的，个人觉得内网环境无需配置CA证书
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="mysql" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/mysql/"/>
    
    
      <category term="mysql" scheme="https://blog.gitee.io/tags/mysql/"/>
    
      <category term="sslca" scheme="https://blog.gitee.io/tags/sslca/"/>
    
  </entry>
  
  <entry>
    <title>jvm容器化内存感知实践</title>
    <link href="https://blog.gitee.io/2021/12/28/dockerjvmarg_action/"/>
    <id>https://blog.gitee.io/2021/12/28/dockerjvmarg_action/</id>
    <published>2021-12-27T16:00:00.000Z</published>
    <updated>2021-12-28T09:02:35.608Z</updated>
    
    <content type="html"><![CDATA[<p><code>docker</code>容器本身需要设置容器的最大可使用内存(防止单个容器消耗节点大量的资源)，跑在容器中的<code>jvm</code>进程也需要设置内存，防止内存占用过大被容器<code>Kill</code>,所以如何优雅的在容器化中设置内存是一个很有必要了解的话题。</p><ul><li><code>jdk 8u131+</code> <code>java 9+</code> 使用参数开启实验性功能 <code>-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap</code>。 开启容器化支持功能。</li><li><code>java 8u191+</code> <code>java10+</code> 使用参数<code>UseContainerSupport</code> 开启容器化感知支持功能。</li><li><code>-XX:MaxRAMPercentage</code> 限制最大<code>heap</code>内存占比 。</li><li><code>-XX:InitialRAMPercentage</code> 设置初始<code>heap</code>内存占比，此参数如果和<code>MaxRAMPercentage</code>设置一样表示jvm最大与最小一致  jvm不会去伸缩内存 这也是一种普遍使用的方式。其值介于0.0到100.0之间，默认值为25。</li></ul><p>上面的几个参数可以让jvm读取<code>cgroup</code>的一些数据，并进行相应的适配，这样容器内jvm超时最大内存 就自己会<code>OOM</code>而不是被容器<code>Kill</code>。关于被<code>OOM</code>后怎么怎么拉取以及存储<code>OOM</code>文件参考 <a href="/2021/11/11/k8s-jvm-dumpcollect">在k8s中收集jvm异常dump文件到OSS</a></p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>以下案例已设置了容器最大可实现内存<code>4G</code> CPU <code>1核</code></p><p>使用参数 限制<code>heap</code>最大内存为80%</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">java  -server -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -XX:MaxRAMPercentage=80.0 ....</span><br></pre></td></tr></table></figure><p>使用jmap查看heap内存情况 显示<code>MaxHeapSize</code>为3278mb 刚好为(4*1021)/0.8 说明jvm能感知到容器最大内存为4g 且只能分配80%的内存给<code>heap</code>。剩余的20%供其他的进程使用。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">jmap -heap 19  </span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 3437232128 (3278.0MB)</span><br><span class="line">   NewSize                  = 22020096 (21.0MB)</span><br><span class="line">   MaxNewSize               = 1145569280 (1092.5MB)</span><br><span class="line">   OldSize                  = 45088768 (43.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br></pre></td></tr></table></figure><p>JDK8+可以使用-XX:MetaspaceSize和-XX:MaxMetaspaceSize设置元空间初始大小以及最大可分配大小。默认情况下，元空间最大的大小是系统内存的大小，该参数一般默认也无所谓 一般不会因为这个太大导致<code>OOM</code>。<br>这也证明了在容器中获取到的内存是宿主机的内存大小而不是设置了容器限制后的大小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;docker&lt;/code&gt;容器本身需要设置容器的最大可使用内存(防止单个容器消耗节点大量的资源)，跑在容器中的&lt;code&gt;jvm&lt;/code&gt;进程也需要设置内存，防止内存占用过大被容器&lt;code&gt;Kill&lt;/code&gt;,所以如何优雅的在容器化中设置内存是一个很有
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="https://blog.gitee.io/tags/docker/"/>
    
      <category term="jvm" scheme="https://blog.gitee.io/tags/jvm/"/>
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="k8s" scheme="https://blog.gitee.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>ingress传递头信息</title>
    <link href="https://blog.gitee.io/2021/12/22/k8s-ingress-annotation1/"/>
    <id>https://blog.gitee.io/2021/12/22/k8s-ingress-annotation1/</id>
    <published>2021-12-21T16:00:00.000Z</published>
    <updated>2021-12-22T02:39:54.071Z</updated>
    
    <content type="html"><![CDATA[<p>在ningx-ingress中内置提供一些<code>annotation</code> 在不手动手动改<code>ingress-controller</code>的情况下可以提供一些方便的操作。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubectl.kubernetes.io/last-applied-configuration:</span> <span class="string">""</span></span><br><span class="line">    <span class="string">nginx.ingress.kubernetes.io/proxy-body-size:</span> <span class="number">50</span><span class="string">m</span></span><br><span class="line">    <span class="string">nginx.ingress.kubernetes.io/service-weight:</span> <span class="string">'show-admin: 100</span></span><br><span class="line"><span class="string">    nginx.ingress.kubernetes.io/server-snippet: |</span></span><br><span class="line"><span class="string">      set sub_domain "";</span></span><br><span class="line"><span class="string">      if ( host ~* (.*)-admin.* )&#123;</span></span><br><span class="line"><span class="string">         set sub_domain saas1;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    nginx.ingress.kubernetes.io/configuration-snippet: |</span></span><br><span class="line"><span class="string">         more_set_input_headers "auth-com: saas$1";</span></span><br><span class="line"><span class="string">  generation: 4</span></span><br><span class="line"><span class="string">  name: test-ingress</span></span><br><span class="line"><span class="string">  namespace: default</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  rules:</span></span><br><span class="line"><span class="string">  - host: test.domain.com</span></span><br><span class="line"><span class="string">    http:</span></span><br><span class="line"><span class="string">      paths:</span></span><br><span class="line"><span class="string">      - backend:</span></span><br><span class="line"><span class="string">          serviceName: test-api</span></span><br><span class="line"><span class="string">          servicePort: 80</span></span><br><span class="line"><span class="string">        path: /</span></span><br><span class="line"><span class="string">status:</span></span><br><span class="line"><span class="string">  loadBalancer: &#123;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>more_set_headers 用于添加、修改、清除响应头</li><li>more_clear_headers 用于清除响应头</li><li>more_set_input_headers 用于添加、修改、清除请求头</li><li>more_clear_input_headers 用于清除请求头</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在ningx-ingress中内置提供一些&lt;code&gt;annotation&lt;/code&gt; 在不手动手动改&lt;code&gt;ingress-controller&lt;/code&gt;的情况下可以提供一些方便的操作。&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="k8s" scheme="https://blog.gitee.io/tags/k8s/"/>
    
      <category term="ingress" scheme="https://blog.gitee.io/tags/ingress/"/>
    
  </entry>
  
  <entry>
    <title>在k8s中收集jvm异常dump文件到OSS</title>
    <link href="https://blog.gitee.io/2021/11/11/k8s-jvm-dumpcollect/"/>
    <id>https://blog.gitee.io/2021/11/11/k8s-jvm-dumpcollect/</id>
    <published>2021-11-10T16:00:00.000Z</published>
    <updated>2021-11-11T04:00:30.523Z</updated>
    
    <content type="html"><![CDATA[<h4 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h4><p>  加参数 <code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=logs/test.dump</code> 可以实现在<code>jvm</code>发生内存错误后 会生成dump文件 方便开发人员分析异常原因。</p><p>  当运行在k8s中，如果进程发生错误 导出dump文件后 ，k8s会重启dokcer容器，上一次崩溃生成的dump文件就没有了。如果应用并没有完全崩溃 此时极其不稳定 最好也能通知到技术人员来处理。这样不方便我们排查原因 所有写了一个小工具。大概原理如下</p><p>  1、 <code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=logs/test.dump</code>   当发生内存错误的时候 导出堆文件<br>  2、 <code>-XX:OnOutOfMemoryError=./dumpError.sh</code>   当发生内存溢出的时候，让JVM调用一个shell脚本 这个shell脚本可以做一些资源整理操作 比如kill掉当前进程并重启</p><p>  依赖上面2点<code>jvm</code>特性 就能做到把dump文件收集起来 是通知技术人员也好(比如发送订单、短信报警等)、然后再把dump文件上传到<code>OSS</code> 或者其他的文件存储中。 需要值得注意的是<code>-XX:OnOutOfMemoryError=xx.sh</code> 执行的脚本不能传脚本参数，所以尽可能把参数都封装在另一个脚本中。</p><h4 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h4><p>基于<code>Go</code>简单的写了一个上传阿里OSS的方法  这里用其他任何语言都可以的，至于用GO的原因很简单,有第三方库可以调用、运行的机器上也不用安装sdk、比较轻量。<br>大致逻辑如下</p><p><code>jvmdump.go</code></p><p>init获取程序的输入参数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"init...."</span>)</span><br><span class="line">flag.StringVar(&amp;env, <span class="string">"env"</span>, <span class="string">"test"</span>, <span class="string">"test"</span>) <span class="comment">//用于区分环境 </span></span><br><span class="line">flag.StringVar(&amp;ddtoken, <span class="string">"ddtoken"</span>, <span class="string">""</span>, <span class="string">"ddtoken"</span>) <span class="comment">//用于报警用的 钉钉机器人TOKEN</span></span><br><span class="line">flag.StringVar(&amp;dumpFile, <span class="string">"dfile"</span>, <span class="string">""</span>, <span class="string">"dfile"</span>) <span class="comment">// dump文件的地址</span></span><br><span class="line">flag.StringVar(&amp;pod, <span class="string">"pod"</span>, <span class="string">""</span>, <span class="string">"pod"</span>) <span class="comment">//k8s中的pod  只是记录一下 方便排查 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数逻辑</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"start invoke dump..."</span>)</span><br><span class="line">flag.Parse() <span class="comment">//解析输入参数</span></span><br><span class="line">fmt.Printf(<span class="string">"dumpFile %s ,env %s token %s\n"</span>,dumpFile,env,ddtoken)</span><br><span class="line">exist, err := FileExists(dumpFile) <span class="comment">//验证dump文件是否存在 只有存在的时候才去处理收集dump文件逻辑</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"验证文件是否存在发生错误![%v]\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> exist &#123;</span><br><span class="line"><span class="comment">//https://help.aliyun.com/document_detail/88604.html</span></span><br><span class="line"><span class="keyword">var</span> url=uploadOSS(dumpFile) <span class="comment">//上传阿里oss</span></span><br><span class="line">fmt.Printf(<span class="string">"OSS上传完成 %s\n"</span>, url)</span><br><span class="line"><span class="keyword">if</span> enabledd&#123;</span><br><span class="line"><span class="comment">//钉钉群机器人发送工具 https://github.com/braumye/grobot </span></span><br><span class="line">notifyDD(url) <span class="comment">//通知钉钉群机器人</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"dump文件不存在 %s\n"</span>,dumpFile)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建可执行文件</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">set GOOS=linux</span><br><span class="line"><span class="keyword">go</span> build -ldflags <span class="string">"-w -s"</span></span><br></pre></td></tr></table></figure><p>测试 验证go脚本是否正确 </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">echo</span> <span class="string">"ffff"</span>&gt;/opt/ttt.dump</span><br><span class="line">./jvmdump -env <span class="built_in">test</span> -dfile /opt/ttt.dump</span><br></pre></td></tr></table></figure><p>如果能成功上传 就可以集成到jvm上跑了，不能成功上传的话 就需要调一下go了。</p><p>另外分享一个<code>-XX:OnOutOfMemoryError=./dumpError.sh</code> 参考。</p><p>有这个shell的原因是因为 由于<code>jvm</code>中<code>OnOutOfMemoryError</code>目前没有找到可以传递脚本参数的方法。 所有不能调用<code>./jvmdump</code>文件 故包装一下，把参数都封装在dempError.sh中 ，把所有生成的dump文件 后缀命名都设置为.dump，主要是为了方便查找。放在一个独立的目录也是可以的。</p><p><code>dumpError.sh</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#循环目录</span></span><br><span class="line">traverse_dir()</span><br><span class="line">&#123;</span><br><span class="line">    filepath=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> `ls -a <span class="variable">$filepath</span>`</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ -d <span class="variable">$&#123;filepath&#125;</span>/<span class="variable">$file</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> [[ <span class="variable">$file</span> != <span class="string">'.'</span> &amp;&amp; <span class="variable">$file</span> != <span class="string">'..'</span> ]]</span><br><span class="line">            <span class="keyword">then</span></span><br><span class="line">                <span class="comment">#递归</span></span><br><span class="line">                traverse_dir <span class="variable">$&#123;filepath&#125;</span>/<span class="variable">$file</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">#调用查找指定后缀文件</span></span><br><span class="line">            check_suffix <span class="variable">$&#123;filepath&#125;</span>/<span class="variable">$file</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="comment">#看需要 可以kill掉进程，避免jvm没有完全崩溃 k8s不会重启pod的情况 造成应用假死问题。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找指定后缀的文件 这里在k8s环境里一般只会有一个dump文件，如果可能存在多个的dump文件文件的情况 可能需要变更一下逻辑</span></span><br><span class="line">check_suffix()</span><br><span class="line">&#123;</span><br><span class="line">    file=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果找到dump就调用go写的jvmdump脚本 </span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;file##*.&#125;</span>"</span>x = <span class="string">"dump"</span>x ];<span class="keyword">then</span></span><br><span class="line">        lib/jvmdump -e <span class="built_in">test</span> -dfile <span class="variable">$file</span> -pod <span class="variable">$HOSTNAME</span> -ddtoken xxx</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line">traverse_dir /opt/logs</span><br></pre></td></tr></table></figure><p>完整代码参考</p><p><a href="https://github.com/peachyy/jvmdump2k8s.git" target="_blank" rel="noopener">https://github.com/peachyy/jvmdump2k8s.git</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;现状&quot;&gt;&lt;a href=&quot;#现状&quot; class=&quot;headerlink&quot; title=&quot;现状&quot;&gt;&lt;/a&gt;现状&lt;/h4&gt;&lt;p&gt;  加参数 &lt;code&gt;-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=logs/test
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jvm" scheme="https://blog.gitee.io/tags/jvm/"/>
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="alpine" scheme="https://blog.gitee.io/tags/alpine/"/>
    
      <category term="k8s" scheme="https://blog.gitee.io/tags/k8s/"/>
    
      <category term="dump" scheme="https://blog.gitee.io/tags/dump/"/>
    
  </entry>
  
  <entry>
    <title>基于alpine构建jdk镜像遇到的坑</title>
    <link href="https://blog.gitee.io/2021/11/10/alpinejdkimage/"/>
    <id>https://blog.gitee.io/2021/11/10/alpinejdkimage/</id>
    <published>2021-11-09T16:00:00.000Z</published>
    <updated>2021-11-10T10:13:26.016Z</updated>
    
    <content type="html"><![CDATA[<p><code>alpine</code>常用于作为<code>docker</code>的基础镜像，因为它很小，功能精简，基本上没有啥漏洞，记录一下最近用<code>alpine</code>作为基础镜像构建<code>java 8</code>镜像 下面的问题在<code>oracle jdk</code> <code>openjdk</code>都会出现 。</p><h4 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NoClassDefFoundError: Could not initialize <span class="class"><span class="keyword">class</span> <span class="title">sun</span>.<span class="title">awt</span>.<span class="title">X11FontManager</span></span></span><br></pre></td></tr></table></figure><p>这个错误一般出现在生成验证码绘制的时候，这个错误大概原因就是由于在<code>alpine</code>上太过于精简了，导致初始化<code>FontManagerFactory</code>工厂初始化失败，那么解决办法就是安装<code>glibc</code>。<br>网上有很多博主都只讲安装了<code>glib.apk</code> 核心包就行，其实这里需要安装3个包 以<code>2.3.0</code>为例 需要安装的包为</p><ul><li><a href="https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.30-r0/glibc-2.30-r0.apk" target="_blank" rel="noopener">https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.30-r0/glibc-2.30-r0.apk</a></li><li><a href="https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.30-r0/glibc-bin-2.30-r0.apk" target="_blank" rel="noopener">https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.30-r0/glibc-bin-2.30-r0.apk</a></li><li><a href="https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.30-r0/glibc-i18n-2.30-r0.apk" target="_blank" rel="noopener">https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.30-r0/glibc-i18n-2.30-r0.apk</a></li></ul><p>安装命令如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">   apk --no-cache add libstdc++ ca-certificates bash  wget</span><br><span class="line">wget -q -O /etc/apk/keys/sgerrand.rsa.pub https://alpine-pkgs.sgerrand.com/sgerrand.rsa.pub</span><br><span class="line">wget https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.30-r0/glibc-2.30-r0.apk</span><br><span class="line">wget https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.30-r0/glibc-bin-2.30-r0.apk</span><br><span class="line">wget https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.30-r0/glibc-i18n-2.30-r0.apk</span><br><span class="line">apk add glibc-2.30-r0.apk &amp;&amp; apk add glibc-bin-2.30-r0.apk &amp;&amp; apk add glibc-i18n-2.30-r0.apk</span><br></pre></td></tr></table></figure><p>安装完后就没有问题了，测试方法 可以写一个main方法在容器中验证是否能执行通过<code>Class.forName(&quot;sun.awt.X11FontManager&quot;);</code>,当在验证码不可行环境的时候 报错的消息为 </p><p><code>/usr/local/jdk1.8.0_301/jre/lib/amd64/libfontmanager.so: libgcc_s.so.1: cann......</code>。</p><p>还有就是可以进入在运行中的容器直接安装 安装完成了之后基本上就没有问题了。</p><h4 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h4><p>   该错误在openJDK中出现过，OracleJDK没有出现。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error while loading shared libraries: libz.so.1: cannot open shared object file:</span><br></pre></td></tr></table></figure><p>解决方式就安装zlib 安装命令如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">curl -Ls https://archive.archlinux.org/packages/z/zlib/zlib-1%3A1.2.9-1-x86_64.pkg.tar.xz -o libz.tar.xz &amp;&amp; mkdir -p libz &amp;&amp; tar -xf libz.tar.xz -C libz</span><br><span class="line"></span><br><span class="line">mv libz/usr/lib/libz.so* /usr/glibc-compat/lib</span><br><span class="line"></span><br><span class="line">rm -rf libz.tar.xz</span><br></pre></td></tr></table></figure><p>安装好后 没有问题了</p><h4 id="dragonwell-openjdk-Dockerfile"><a href="#dragonwell-openjdk-Dockerfile" class="headerlink" title="dragonwell openjdk Dockerfile"></a>dragonwell openjdk Dockerfile</h4><p>另贴上基于<code>alpine</code>的阿里<code>dragonwell openjdk</code>的Dockerfile</p><p>dragonwell JDK Dockerfile</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">FROM alpine:3.8</span><br><span class="line">LABEL maintainer="xstao"</span><br><span class="line">ENV TZ=Asia/Shanghai</span><br><span class="line">RUN ln -snf /usr/share/zoneinfo/$&#123;TZ&#125; /etc/localtime &amp;&amp; \</span><br><span class="line">    echo $&#123;TZ&#125; &gt; /etc/timezone</span><br><span class="line"><span class="meta">#</span><span class="bash">mirrons aliun</span></span><br><span class="line">RUN echo http://mirrors.aliyun.com/alpine/v3.10/main/ &gt; /etc/apk/repositories &amp;&amp; \</span><br><span class="line">    echo http://mirrors.aliyun.com/alpine/v3.10/community/ &gt;&gt; /etc/apk/repositories</span><br><span class="line">    RUN apk update &amp;&amp; apk upgrade</span><br><span class="line"><span class="meta">#</span><span class="bash">install glibc</span></span><br><span class="line">RUN apk --no-cache add libstdc++ ca-certificates bash  wget curl  &amp;&amp; \</span><br><span class="line">    wget -q -O /etc/apk/keys/sgerrand.rsa.pub https://alpine-pkgs.sgerrand.com/sgerrand.rsa.pub  &amp;&amp; \</span><br><span class="line">    wget https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.30-r0/glibc-2.30-r0.apk &amp;&amp; \</span><br><span class="line">    wget https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.30-r0/glibc-bin-2.30-r0.apk &amp;&amp; \</span><br><span class="line">    wget https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.30-r0/glibc-i18n-2.30-r0.apk &amp;&amp; \</span><br><span class="line">    apk add glibc-2.30-r0.apk &amp;&amp; apk add glibc-bin-2.30-r0.apk &amp;&amp; apk add glibc-i18n-2.30-r0.apk &amp;&amp; \</span><br><span class="line">    curl -Ls https://archive.archlinux.org/packages/z/zlib/zlib-1%3A1.2.9-1-x86_64.pkg.tar.xz -o libz.tar.xz &amp;&amp; mkdir -p libz &amp;&amp; tar -xf libz.tar.xz -C libz &amp;&amp; \</span><br><span class="line">    mv libz/usr/lib/libz.so* /usr/glibc-compat/lib &amp;&amp; \</span><br><span class="line">    rm glibc-2.30-r0.apk &amp;&amp; rm glibc-bin-2.30-r0.apk &amp;&amp; rm glibc-i18n-2.30-r0.apk &amp;&amp; rm -rf /var/cache/apk/* &amp;&amp; rm -rf libz/* &amp;&amp;  rm -rf libz.tar.xz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apk add --update font-adobe-100dpi ttf-dejavu fontconfig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENV JAVA_VERSION="jdk8u302-b01"</span><br><span class="line">ENV JAVA_HOME="/usr/local/$&#123;JAVA_VERSION&#125;"</span><br><span class="line"></span><br><span class="line">ENV PATH="$&#123;JAVA_HOME&#125;/bin:$&#123;PATH&#125;"</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">WORKDIR /opt</span><br><span class="line">RUN wget https://dragonwell.oss-cn-shanghai.aliyuncs.com/8.8.9/Alibaba_Dragonwell_8.8.9_x64_linux.tar.gz</span><br><span class="line">RUN tar -zxf Alibaba_Dragonwell_8.8.9_x64_linux.tar.gz</span><br><span class="line">RUN mv $&#123;JAVA_VERSION&#125; /usr/local</span><br><span class="line">RUN rm -rf Alibaba_Dragonwell_8.8.9_x64_linux.tar.gz</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;alpine&lt;/code&gt;常用于作为&lt;code&gt;docker&lt;/code&gt;的基础镜像，因为它很小，功能精简，基本上没有啥漏洞，记录一下最近用&lt;code&gt;alpine&lt;/code&gt;作为基础镜像构建&lt;code&gt;java 8&lt;/code&gt;镜像 下面的问题在&lt;code&gt;
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="alpine" scheme="https://blog.gitee.io/tags/alpine/"/>
    
      <category term="jdk" scheme="https://blog.gitee.io/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>docker删除&lt;none&gt;标签镜像</title>
    <link href="https://blog.gitee.io/2021/08/23/dockerimage-prune/"/>
    <id>https://blog.gitee.io/2021/08/23/dockerimage-prune/</id>
    <published>2021-08-22T16:00:00.000Z</published>
    <updated>2021-08-23T08:42:31.705Z</updated>
    
    <content type="html"><![CDATA[<p>被打上<code>&lt;none&gt;</code>标签的镜像指的是没有标签并且没有被容器使用的镜像。<br>如果不清理这种镜像会大量占用机器磁盘。记录2种自身工作中常用的删除方法。</p><h4 id="第一种删除方式"><a href="#第一种删除方式" class="headerlink" title="第一种删除方式"></a>第一种删除方式</h4><p>执行下面shell 并输入<code>y</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h4 id="第二种方式删除"><a href="#第二种方式删除" class="headerlink" title="第二种方式删除"></a>第二种方式删除</h4><p> 利用<code>awk</code>来获取镜像id 执行<code>docker rmi</code>删除</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images | grep "none" | awk '&#123;print $3&#125;')</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;被打上&lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;标签的镜像指的是没有标签并且没有被容器使用的镜像。&lt;br&gt;如果不清理这种镜像会大量占用机器磁盘。记录2种自身工作中常用的删除方法。&lt;/p&gt;
&lt;h4 id=&quot;第一种删除方式&quot;&gt;&lt;a href=&quot;#第一种删除方式&quot; cla
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="https://blog.gitee.io/tags/docker/"/>
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes之pod</title>
    <link href="https://blog.gitee.io/2021/08/09/k8s-pod/"/>
    <id>https://blog.gitee.io/2021/08/09/k8s-pod/</id>
    <published>2021-08-08T16:00:00.000Z</published>
    <updated>2021-08-09T05:52:10.939Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="kubernetes" scheme="https://blog.gitee.io/tags/kubernetes/"/>
    
      <category term="pod" scheme="https://blog.gitee.io/tags/pod/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes-kubeadm创建集群</title>
    <link href="https://blog.gitee.io/2021/08/05/k8s-kubeadm-init-2/"/>
    <id>https://blog.gitee.io/2021/08/05/k8s-kubeadm-init-2/</id>
    <published>2021-08-04T16:00:00.000Z</published>
    <updated>2021-08-05T05:40:56.172Z</updated>
    
    <content type="html"><![CDATA[<p>这一节基本上会遇到很多异常错误信息，需要耐心的去解决它，跟环境等很多因素有关系。</p><h4 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h4><p>在master 机器上初始化集群 会自动拉取相关的镜像 需要等待一下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init --image-repository registry.aliyuncs.com/google_containers --service-cidr=10.96.0.0/12 --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=192.168.0.213</span><br></pre></td></tr></table></figure><p>正常情况下 这里会报错，[ERROR ImagePull]: failed to pull image registry.aliyuncs.com/google_containers/coredns:v1.8.0: output: Error response from daemon: manifest for registry.aliyuncs.com/google_containers/coredns:v1.8.0 not found: manifest unknown: manifest unknown</p><p>原因是 期望自动下载的镜像为 <code>registry.aliyuncs.com/google_containers/coredns:v1.8.0</code>，然后仓库中并这个容器镜像，查了资料可以手动下载指定版本号的时候把<code>v</code>去掉即可，下载后并重命名一下版本号</p><p>手动拉取镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">下载</span><br><span class="line"><span class="meta">#</span><span class="bash">docker pull registry.aliyuncs.com/google_containers/coredns:1.8.0</span></span><br><span class="line">重命名</span><br><span class="line"><span class="meta">#</span><span class="bash">docker tag registry.aliyuncs.com/google_containers/coredns:1.8.0 registry.aliyuncs.com/google_containers/coredns:v1.8.0</span></span><br></pre></td></tr></table></figure><p>然后再执行 <code>kubeadm init --image-repository registry.aliyuncs.com/google_containers --service-cidr=10.96.0.0/12 --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=192.168.0.213</code> 就不会报错了。执行完成后打印<br>执行完成后打印<code>Your Kubernetes control-plane has initialized successfully!</code>表示已经成功初始化。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>在初始化结果日志中还打印了加入集群的令牌(token),令牌用于控制平面节点和加入节点之间的相互身份验证。 这里包含的令牌是密钥。确保它的安全， 因为拥有此令牌的任何人都可以将经过身份验证的节点添加到你的集群中。</p><h4 id="节点加入集群"><a href="#节点加入集群" class="headerlink" title="节点加入集群"></a>节点加入集群</h4><p>在work机器上执行加入节点到机器操作 要保证work机器上要能和master网络保持畅通,直接复制init 命令日志中最后一段话命令就行。<br>加入的时候要保证work节点上的docker服务是开启的。不然要报错。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.0.213:6443 --token 5aqi11.werqxkrz4e46vnih --discovery-token-ca-cert-hash sha256:4794a2e13e2c566070d6b289981abb267a0fce1dbf78d60c21db618719d764e7</span><br></pre></td></tr></table></figure></p><p>加入成功后在master上执行<code>kubectl get nodes</code>会发现多了一个节点 但是状态是NotReady，这是不同的机器上容器内部网络不互通 接下来就来整一下网络。</p><h4 id="网络模型插件"><a href="#网络模型插件" class="headerlink" title="网络模型插件"></a>网络模型插件</h4><p> 目前<code>Kubernetes</code>比较常用的网络组建 主要是<code>flannel</code>、<code>Calico</code> 这里我们选用<code>flannel</code>做网络模型。安装方法也就是允许容器 还是比较方便。需要在<code>master</code>上执行</p><p> 下载yml文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p>在集群中运行容器<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply  -f kube-flannel.yml</span><br></pre></td></tr></table></figure></p><p>这里可能会遇到很多问题，安装好网络插件了 怎么节点还是NotReady状态呢？这些就要对问题进行进一步排查了。这个命令可以看到node上一些问题<code>journalctl -u kubelet -n 300</code>.<br>节点还是依然处理NotReady，就可能是环境有什么问题了，在Master上执行<code>kubectl describe node test1</code> test1为状态异常的节点名称，就能看到这个节点当前的调度操作日志。比如这次有一台work机器日志显示为<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Normal  Starting                 18s                kubelet  Starting kubelet.</span><br><span class="line">Normal  NodeHasSufficientPID     1s                 kubelet  Node test1 status is now: NodeHasSufficientPID</span><br><span class="line">Normal  Starting                 1s                 kubelet  Starting kubelet.</span><br><span class="line">Normal  NodeHasSufficientMemory  1s                 kubelet  Node test1 status is now: NodeHasSufficientMemory</span><br><span class="line">Normal  NodeHasNoDiskPressure    1s                 kubelet  Node test1 status is now: NodeHasNoDiskPressure</span><br></pre></td></tr></table></figure></p><p> 能看到一些有用的信息 如 磁盘空间不足。</p><p> 出现了异常 看哪些命令没有启动成功 可以参考以下的命令日志</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl -l -u kube-apiserver</span><br><span class="line">journalctl -l -u kube-controller-manager</span><br><span class="line">journalctl -l -u kube-scheduler</span><br><span class="line">journalctl -l -u kubelet</span><br><span class="line">journalctl -l -u kube-proxy</span><br></pre></td></tr></table></figure><p>如果节点状态都为<code>Ready</code> 那真是太幸运了。安装好网络插件后 一般要等待1-2分钟才会变为Ready，接下来就可能把应用部署在k8s集群中去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节基本上会遇到很多异常错误信息，需要耐心的去解决它，跟环境等很多因素有关系。&lt;/p&gt;
&lt;h4 id=&quot;初始化集群&quot;&gt;&lt;a href=&quot;#初始化集群&quot; class=&quot;headerlink&quot; title=&quot;初始化集群&quot;&gt;&lt;/a&gt;初始化集群&lt;/h4&gt;&lt;p&gt;在master 机器
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="kubernetes" scheme="https://blog.gitee.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes-kubeadm安装</title>
    <link href="https://blog.gitee.io/2021/08/04/k8s-kubeadm-1/"/>
    <id>https://blog.gitee.io/2021/08/04/k8s-kubeadm-1/</id>
    <published>2021-08-03T16:00:00.000Z</published>
    <updated>2021-08-04T08:49:19.707Z</updated>
    
    <content type="html"><![CDATA[<p><code>kubeadm</code>是目前官方最推荐的安装方式，既可以用于安装学习玩一下，也可以用来安装高可用集群。这里的操作系统都是以centos7为例 其他系统类似。</p><p>环境准备 </p><p>master 192.168.0.213<br>work 192.168.0.212<br>work 192.168.0.211</p><p>需要在3台服务器上执行一下配置更改。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>将 SELinux 设置为 permissive 模式（相当于将其禁用）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config</span><br></pre></td></tr></table></figure><p>关闭swap</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sed -ri <span class="string">'s/.*swap.*/#&amp;/'</span> <span class="regexp">/etc/</span>fstab </span><br><span class="line">swapoff -a</span><br></pre></td></tr></table></figure><p>导入yum源 用aliyun的镜像地址，默认是google 国内根本就下载不了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>执行安装并启用操作，等待下载安装完成。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure><p>执行如果没有出错 差不多就安装完成了，如果遇到错误可以查阅故障排除资料 <a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;kubeadm&lt;/code&gt;是目前官方最推荐的安装方式，既可以用于安装学习玩一下，也可以用来安装高可用集群。这里的操作系统都是以centos7为例 其他系统类似。&lt;/p&gt;
&lt;p&gt;环境准备 &lt;/p&gt;
&lt;p&gt;master 192.168.0.213&lt;br&gt;work 
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="kubernetes" scheme="https://blog.gitee.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>找出JVM中最耗cpu的线程</title>
    <link href="https://blog.gitee.io/2020/12/11/find_jvm_cpu_max_thread/"/>
    <id>https://blog.gitee.io/2020/12/11/find_jvm_cpu_max_thread/</id>
    <published>2020-12-10T16:00:00.000Z</published>
    <updated>2021-08-27T03:32:17.182Z</updated>
    
    <content type="html"><![CDATA[<p>1、<code>top</code>命令查找出cpu最高的java进程<code>pid</code></p><p>2、<code>top -Hp</code> 命令找出进程内最耗线程的<code>pid</code></p><pre><code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top -Hp 22293</span><br></pre></td></tr></table></figure></code></pre><p>3、获取到上一步线程的<code>pid</code>后  将<code>pid</code> 16进制输出 </p><pre><code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">printf</span> <span class="string">'%x\n'</span> 22801</span></span><br><span class="line">5911</span><br></pre></td></tr></table></figure></code></pre><p>4 使用<code>jstack</code>命令找出线程信息 jstack 进程pid |grep  16进制后的线程号</p><pre><code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> jstack 22293|grep 5911</span></span><br><span class="line">"DubboServerHandler-192.168.0.11:20880-thread-345" #474 daemon prio=5 os_prio=0 tid=0x00007f74940dc800 nid=0x5911 waiting on condition [0x00007f745c873000]</span><br></pre></td></tr></table></figure></code></pre><p>这样就很直观的看到 线程名称为DubboServerHandler的线程占用最高。 通常如果是FullGC频繁的话 这里的线程应该是GC回收线程。</p><p>GC总体内存概述 使用jstat命令可以快速查看 </p><p>jstat -gcutil 进程pid 滚动时间可不设置</p><pre><code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat -gcutil 22293 3000</span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">0.00  85.62  34.27  21.19  92.31  88.54    495   10.072     4    0.733   10.805</span><br><span class="line">0.00  85.62  35.71  21.19  92.31  88.54    495   10.072     4    0.733   10.805</span><br></pre></td></tr></table></figure></code></pre><p>如果是FullGC次数太频繁 需要查一下内存中是哪些对象不能回收导致的</p><p>查询前20个大对象 根据大对象的ClassName大概率知道是哪些原因导致的问题</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -histo:live pid|head -n 20 </span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">dump堆栈的快照信息 这个操作在操作过程中会导致应用暂停  线上系统需要谨慎操作</span><br><span class="line"></span><br><span class="line">``` shell</span><br><span class="line">jmap -dump:format=b,live,file=0623.dump pid</span><br></pre></td></tr></table></figure><p><code>live</code> 参数表示 只导出活动的对象 可以去掉<br><code>file</code> 导出路径<br><code>format</code> 导出格式 指定为format=b就行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、&lt;code&gt;top&lt;/code&gt;命令查找出cpu最高的java进程&lt;code&gt;pid&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;top -Hp&lt;/code&gt; 命令找出进程内最耗线程的&lt;code&gt;pid&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure cla
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jvm" scheme="https://blog.gitee.io/tags/jvm/"/>
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>更好用 更简单的Java缓存框架 jscache</title>
    <link href="https://blog.gitee.io/2020/08/21/jscache/"/>
    <id>https://blog.gitee.io/2020/08/21/jscache/</id>
    <published>2020-08-20T16:00:00.000Z</published>
    <updated>2020-08-21T08:59:26.492Z</updated>
    
    <content type="html"><![CDATA[<p> 比Spring Cache 更好用 更简单的缓存工具 <code>jscache</code> 取名意义为 <em>java simple cache</em>，基于<code>AOP</code>实现，支持注解到接口 自定义单个缓存过期时间配置 <code>ttl</code>，轻松扩展缓存实现，默认实现了<code>jedis</code>,<code>spring-data-redis</code>,还有一个基于本地内存的<code>map</code>。</p><p>源码仓库 <a href="https://github.com/peachyy/jscache.git" target="_blank" rel="noopener">https://github.com/peachyy/jscache.git</a> </p><h3 id="注解API"><a href="#注解API" class="headerlink" title="注解API"></a>注解API</h3><h5 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h5><p>  设置/获取缓存 如果当前KEY对应的缓存存在就直接返回，不存在则调用服务后 再对结果进行缓存。</p><p>  配置项</p><ul><li>prefix  缓存前缀</li><li>key     key 是 <code>el</code> 表达式 默认生成后的缓存key为 <code>prefix+key</code></li><li>ttl     缓存存活时间(过期时间) 需要具体的缓存实现支持 如常用的<code>redis</code>是支持的</li><li>argCondition     前置条件过滤 针对参数过滤 满足则执行表达式逻辑</li><li>returnCondition  后置条件过滤 只有前置条件为<code>true</code>的情况下才能到达后置过滤 为<code>true</code>才会把结果放入缓存中</li><li><p>allowNullValue    返回值为空的情况下是否缓存 防止缓存穿透可以支持为<code>true</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Cacheable</span>(prefix = <span class="string">"user:"</span>,key = <span class="string">"#p0"</span>,</span><br><span class="line">ttl = <span class="number">60</span>,returnCondition = <span class="string">"#result!=null"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">      User user=<span class="keyword">new</span> User();</span><br><span class="line">      user.setId(userId);</span><br><span class="line">      user.setName(<span class="string">"xxx"</span>);</span><br><span class="line">      log.info(<span class="string">"GET getUserById"</span>);</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h5><p>  只是设置(put)缓存 无论缓存是否存在 这里支持设置(put)多个缓存</p><p>  配置项 与 cacheable类似</p><ul><li>prefix  缓存前缀</li><li>key     key 是 <code>el</code> 表达式 默认生成后的缓存key为 <code>prefix+key</code></li><li>ttl     缓存存活时间(过期时间) 需要具体的缓存实现支持 如常用的<code>redis</code>是支持的</li><li>argCondition     前置条件过滤 针对参数过滤 满足则执行表达式逻辑</li><li>returnCondition  后置条件过滤 只有前置条件为<code>true</code>的情况下才能到达后置过滤 为<code>true</code>才会把结果放入缓存中</li><li><p>allowNullValue    返回值为空的情况下是否缓存 防止缓存穿透可以支持为<code>true</code>  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CachePut</span>(prefix = <span class="string">"user:"</span>,key = <span class="string">"#p0"</span>)</span><br><span class="line"><span class="meta">@CachePut</span>(prefix = <span class="string">"members:"</span>,key = <span class="string">"#p0"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    user.setId(userId);</span><br><span class="line">    user.setName(<span class="string">"xxx"</span>);</span><br><span class="line">    log.info(<span class="string">"GET getUserById"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h5><p>  删除缓存 支持删除多个缓存</p><p>  配置项</p><ul><li>prefix  缓存前缀</li><li>key     key 是 <code>el</code> 表达式 默认生成后的缓存key为 <code>prefix+key</code></li><li>argCondition     前置条件过滤 针对参数过滤 满足则执行表达式逻辑</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheEvict</span>(prefix = <span class="string">"members:"</span>,key = <span class="string">"#p0"</span>)</span><br><span class="line"><span class="meta">@CacheEvict</span>(prefix = <span class="string">"user:"</span>,key = <span class="string">"#p0"</span>,argCondition = <span class="string">"#p0==100"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    user.setId(userId);</span><br><span class="line">    user.setName(<span class="string">"xxx"</span>);</span><br><span class="line">    log.info(<span class="string">"GET getUserById"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开始使用缓存"><a href="#开始使用缓存" class="headerlink" title="开始使用缓存"></a>开始使用缓存</h4><p>   如springboot中 标注<code>@EnableCache</code>注解 表示缓存功能启用 只要标注了注解的就会生效。</p><p>   引入jar<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.peachyy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jscache-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;last.jscache.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>  启用缓存 并配置一个缓存实现。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCache</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JedisCache <span class="title">cache</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Properties properties=<span class="keyword">new</span> Properties();</span><br><span class="line">       properties.put(<span class="string">"hosts"</span>,<span class="string">"192.168.0.2:6379"</span>);</span><br><span class="line">       properties.put(<span class="string">"password"</span>,<span class="string">"bac123"</span>);</span><br><span class="line">       properties.put(<span class="string">"database"</span>,<span class="string">"0"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> JedisCache(properties,<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>  这里有一个基于springboot的例子 <a href="https://github.com/peachyy/jscache/tree/master/jscache-springmvc-example" target="_blank" rel="noopener">https://github.com/peachyy/jscache/tree/master/jscache-springmvc-example</a></p><h4 id="更多适配"><a href="#更多适配" class="headerlink" title="更多适配"></a>更多适配</h4><p>   主要是用于针对部分rpc 如<code>dubbo</code> 当使用<code>@Reference</code>注解 实例没有被<code>spring ioc</code>管理到 就不能到框架AOP 所以提供一些简单的支持 目前仅实现了<code>dubbo</code>的这种情况</p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ul><li>jscache-annotation 只是注解包  比如标注在接口上 而这个接口需要给其它地方引用 就只需要引用这个jar就好，免得过多产生过多的依赖</li><li>jscache-core       核心功能实现</li><li>jscache-dubbo      针对没有被spring管理<code>dubbo service</code>的适配 基于<code>filter</code>实现</li><li>jscache-springmvc-example 一个springboot 简单例子</li></ul><h4 id="序列化以及其它扩展"><a href="#序列化以及其它扩展" class="headerlink" title="序列化以及其它扩展"></a>序列化以及其它扩展</h4><p>序列化</p><p> 序列化只针对值 key默认为<code>String</code>字符，方便监控查看。自定义序列化需要实现 <code>com.peachyy.jscache.core.serialize.Serializer</code>接口。默认的实现有<code>fastJson</code>,<code>jackson</code>,<code>java</code> 自定义的直接传自定义的全类名就行。</p><p> 如 扩展了一个<code>com.xxx.myJacksonSerializer</code>序列化方式 设置的方式大概就是这样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCache</span>(serializer=<span class="string">"com.xxx.myJacksonSerializer"</span>)</span><br></pre></td></tr></table></figure><p>扩展缓存实现<br>  扩展缓存需要实现<code>com.peachyy.jscache.core.Cache</code>接口，加入spring容器就完事了。不需要复杂的实现</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JedisCache <span class="title">cache</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Properties properties=<span class="keyword">new</span> Properties();</span><br><span class="line">    properties.put(<span class="string">"hosts"</span>,<span class="string">"192.168.0.2:6379"</span>);</span><br><span class="line">    properties.put(<span class="string">"password"</span>,<span class="string">"bac123"</span>);</span><br><span class="line">    properties.put(<span class="string">"database"</span>,<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JedisCache(properties,<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和spring cache比起来使用上的功能大部分有，一些设计也参考了它，使用上明显的差别就是支持了ttl过期时间，去掉了cacheManager设计，但是仅不止如此 开发者更易驾驭，一个系统中一般保持一套缓存规范就够了。总之适合就是最好的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 比Spring Cache 更好用 更简单的缓存工具 &lt;code&gt;jscache&lt;/code&gt; 取名意义为 &lt;em&gt;java simple cache&lt;/em&gt;，基于&lt;code&gt;AOP&lt;/code&gt;实现，支持注解到接口 自定义单个缓存过期时间配置 &lt;code&gt;ttl&lt;/c
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="jscache" scheme="https://blog.gitee.io/tags/jscache/"/>
    
  </entry>
  
  <entry>
    <title>Neo4j入门教程</title>
    <link href="https://blog.gitee.io/2019/08/23/neo4j_study/"/>
    <id>https://blog.gitee.io/2019/08/23/neo4j_study/</id>
    <published>2019-08-22T16:00:00.000Z</published>
    <updated>2019-08-23T07:31:21.272Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一章：介绍"><a href="#第一章：介绍" class="headerlink" title="第一章：介绍"></a>第一章：介绍</h4><h5 id="Neo4j是什么"><a href="#Neo4j是什么" class="headerlink" title="Neo4j是什么"></a>Neo4j是什么</h5><p>Neo4j是一个高性能的,NOSQL图形数据库，它将结构化数据存储在网络上而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎，但是它将结构化数据存储在网络(从数学角度叫做图)上而不是表中。Neo4j也可以被看作是一个高性能的图引擎，该引擎具有成熟数据库的所有特性。程序员工作在一个面向对象的、灵活的网络结构下而不是严格、静态的表中——但是他们可以享受到具备完全的事务特性、企业级的数据库的所有好处。</p><h5 id="Neo4j的特点"><a href="#Neo4j的特点" class="headerlink" title="Neo4j的特点"></a>Neo4j的特点</h5><p>SQL就像简单的查询语言Neo4j CQL<br>它遵循属性图数据模型<br>它通过使用Apache Lucence支持索引<br>它支持UNIQUE约束<br>它它包含一个用于执行CQL命令的UI：Neo4j数据浏览器<br>它支持完整的ACID（原子性，一致性，隔离性和持久性）规则<br>它采用原生图形库与本地GPE（图形处理引擎）<br>它支持查询的数据导出到JSON和XLS格式<br>它提供了REST API，可以被任何编程语言（如Java，Spring，Scala等）访问<br>它提供了可以通过任何UI MVC框架（如Node JS）访问的Java脚本<br>它支持两种Java API：Cypher API和Native Java API来开发Java应用程序</p><h5 id="Neo4j的优点"><a href="#Neo4j的优点" class="headerlink" title="Neo4j的优点"></a>Neo4j的优点</h5><p>它很容易表示连接的数据<br>检索/遍历/导航更多的连接数据是非常容易和快速的<br>它非常容易地表示半结构化数据<br>Neo4j CQL查询语言命令是人性化的可读格式，非常容易学习<br>它使用简单而强大的数据模型<br>它不需要复杂的连接来检索连接的/相关的数据，因为它很容易检索它的相邻节点或关系细节没有连接或索引</p><h4 id="第二章：安装"><a href="#第二章：安装" class="headerlink" title="第二章：安装"></a>第二章：安装</h4><h5 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h5><p>Centos 7.4</p><p>neo4j-community-3.4.1.tar.gz</p><h5 id="2-下载"><a href="#2-下载" class="headerlink" title="2.下载"></a>2.下载</h5><p>下载地址 <a href="https://neo4j.com/download/other-releases/" target="_blank" rel="noopener">https://neo4j.com/download/other-releases/</a></p><p>下载</p><p>wget <a href="https://neo4j.com/artifact.php?name=neo4j-community-3.4.1-unix.tar.gz" target="_blank" rel="noopener">https://neo4j.com/artifact.php?name=neo4j-community-3.4.1-unix.tar.gz</a><br>解压</p><p>tar -zxvf neo4j-community-3.4.1.tar.gz</p><h5 id="3-开启远程访问"><a href="#3-开启远程访问" class="headerlink" title="3.开启远程访问"></a>3.开启远程访问</h5><p>一、对于3.0以前的版本</p><p>在安装目录的 $NEO4J_HOME/conf/neo4j.conf 文件内，找到下面一行，将注释#号去掉就可以了 #dbms.connector.https.address=localhost:7473 改为 dbms.connector.https.address=0.0.0.0:7473 这样，远程其他电脑可以用本机的IP或者域名后面跟上7474 端口就能打开web界面了 如： https://:7473</p><p>当然，你的操作系统的防火墙也要确保开放了7474端口才行，防火墙怎样开放请自行针对自己的操作系统查找文档</p><p>二、对于3.1及以后的版本</p><p>在安装目录的 $NEO4J_HOME/conf/neo4j.conf 文件内，找到下面一行，将注释#号去掉就可以了 dbms.connectors.default_listen_address=0.0.0.0</p><h5 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h5><p>在bin目录下，执行命令：./neo4j start启动，其他命令 { console | start | stop | restart | status } </p><p>访问<a href="http://IP地址:7474/" target="_blank" rel="noopener">http://IP地址:7474/</a>, 出现下图即代表安装成功，顶部的$输入框用来执行下面的CQL语句。</p><h4 id="第三章：CQL"><a href="#第三章：CQL" class="headerlink" title="第三章：CQL"></a>第三章：CQL</h4><h5 id="1-CQL简介"><a href="#1-CQL简介" class="headerlink" title="1.CQL简介"></a>1.CQL简介</h5><p>CQL代表Cypher查询语言。 像Oracle数据库具有查询语言SQL，Neo4j具有CQL作为查询语言。</p><h6 id="Neo4j-CQL"><a href="#Neo4j-CQL" class="headerlink" title="Neo4j CQL -"></a>Neo4j CQL -</h6><ul><li>它是Neo4j图形数据库的查询语言。</li><li>它是一种声明性模式匹配语言</li><li>它遵循SQL语法。</li><li><p>它的语法是非常简单且人性化、可读的格式。</p><h6 id="如Oracle-SQL"><a href="#如Oracle-SQL" class="headerlink" title="如Oracle SQL -"></a>如Oracle SQL -</h6></li><li><p>Neo4j CQL 命令来执行数据库操作。</p></li><li>Neo4j CQL 支持多个子句像在哪里，顺序等，以非常简单的方式编写非常复杂的查询。</li><li><p>NNeo4j CQL 支持一些功能，如字符串，Aggregation.In 加入他们，它还支持一些关系功能。</p><h5 id="2-Neo4j-CQL命令-条款"><a href="#2-Neo4j-CQL命令-条款" class="headerlink" title="2.Neo4j CQL命令/条款"></a>2.Neo4j CQL命令/条款</h5><p>常用的Neo4j CQL命令/条款如下：</p></li><li><p>CREATE     创建节点，关系和属性</p></li><li>MATCH      检索有关节点，关系和属性数据</li><li>RETURN     返回查询结果</li><li>WHERE       提供条件过滤检索数据</li><li>DELETE      删除节点和关系</li><li>REMOVE     删除节点和关系的属性</li><li>ORDER BY   ORDER BY以…排序 排序检索数据</li><li>SET         添加或更新标签</li></ul><h5 id="3-Neo4j-CQL-函数"><a href="#3-Neo4j-CQL-函数" class="headerlink" title="3.Neo4j CQL 函数"></a>3.Neo4j CQL 函数</h5><p>以下是常用的Neo4j CQL函数：</p><ul><li><p>String 字符串 它们用于使用String字面量。</p></li><li><p>Aggregation 聚合 它们用于对CQL查询结果执行一些聚合操作。</p></li><li><p>Relationship 关系 他们用于获取关系的细节，如startnode，endnode等。</p></li></ul><p>我们将在后面的章节中详细讨论所有Neo4j CQL命令，子句和函数语法，用法和示例。</p><h5 id="4-Neo4j-CQL数据类型"><a href="#4-Neo4j-CQL数据类型" class="headerlink" title="4.Neo4j CQL数据类型"></a>4.Neo4j CQL数据类型</h5><p>这些数据类型与Java语言类似。 它们用于定义节点或关系的属性</p><p>Neo4j CQL支持以下数据类型：</p><table><thead><tr><th>No.</th><th style="text-align:center">CQL数据类型</th><th style="text-align:right">用法</th></tr></thead><tbody><tr><td>1.</td><td style="text-align:center">boolean</td><td style="text-align:right">用于表示布尔文字：true，false。</td></tr><tr><td>2.</td><td style="text-align:center">byte</td><td style="text-align:right">用于表示8位整数。</td></tr><tr><td>3.</td><td style="text-align:center">short</td><td style="text-align:right">用于表示16位整数。</td></tr><tr><td>4.</td><td style="text-align:center">int</td><td style="text-align:right">用于表示32位整数。</td></tr><tr><td>5.</td><td style="text-align:center">long</td><td style="text-align:right">用于表示64位整数。</td></tr><tr><td>6.</td><td style="text-align:center">float</td><td style="text-align:right">用于表示32位浮点数。</td></tr><tr><td>7.</td><td style="text-align:center">double</td><td style="text-align:right">用于表示64位浮点数。</td></tr><tr><td>8.</td><td style="text-align:center">char</td><td style="text-align:right">用于表示16位字符。</td></tr><tr><td>9.</td><td style="text-align:center">String</td><td style="text-align:right">用于表示字符串。</td></tr></tbody></table><h4 id="第四章：命令"><a href="#第四章：命令" class="headerlink" title="第四章：命令"></a>第四章：命令</h4><h5 id="1-CREATE创建"><a href="#1-CREATE创建" class="headerlink" title="1.CREATE创建"></a>1.CREATE创建</h5><p>Neo4j CQL创建一个没有属性的节点</p><p>CREATE (<node-name>:<label-name>)<br>语法说明</label-name></node-name></p><p>规范说法是节点标签名称，其实相当于Mysql数据库中的表名，而是节点名称，其实代指创建的此行数据。</p><p>示例</p><p>CREATE (emp:Employee)<br>或者</p><p>CREATE (:Employee)<br>Neo4j CQL创建具有属性的节点</p><p>Neo4j CQL“CREATE”命令用于创建带有属性的节点。 它创建一个具有一些属性（键值对）的节点来存储数据。</p><pre><code class="shell">CREATE (   &lt;node-name&gt;:&lt;label-name&gt;   {          &lt;key&gt;:&lt;Value&gt;      ........      &lt;n-key&gt;:&lt;n-Value&gt;   })</code></pre><p>示例</p><p>CREATE (dept:Dept { deptno:10,dname:”Accounting”,location:”Hyderabad” })<br>创建多个标签到节点</p><p>语法：</p><p>CREATE (<node-name>:<label-name1>:<label-name2>…..:<label-namen>)<br>示例</label-namen></label-name2></label-name1></node-name></p><p>CREATE (m:Movie:Cinema:Film:Picture)</p><h5 id="2-MATCH查询"><a href="#2-MATCH查询" class="headerlink" title="2.MATCH查询"></a>2.MATCH查询</h5><p>Neo4j CQL MATCH命令用于</p><p>从数据库获取有关节点和属性的数据<br>从数据库获取有关节点，关系和属性的数据<br>MATCH命令语法：</p><pre><code class="shell">MATCH (   &lt;node-name&gt;:&lt;label-name&gt;)</code></pre><p>示例</p><p>MATCH (dept:Dept)<br>但是执行后会报错：</p><p>Neo.ClientError.Statement.SyntaxError:<br>Query cannot conclude with MATCH<br>(must be RETURN or an update clause) (line 1, column 1 (offset: 0))<br>如果你观察到错误消息，它告诉我们，我们可以使用MATCH命令与RETURN子句或UPDATA子句。</p><h5 id="3-RETURN返回"><a href="#3-RETURN返回" class="headerlink" title="3.RETURN返回"></a>3.RETURN返回</h5><p>Neo4j CQL RETURN子句用于 -</p><p>检索节点的某些属性<br>检索节点的所有属性<br>检索节点和关联关系的某些属性<br>检索节点和关联关系的所有属性<br>RETURN命令语法：</p><pre><code class="shell">RETURN    &lt;node-name&gt;.&lt;property1-name&gt;,   ........   &lt;node-name&gt;.&lt;propertyn-name&gt;</code></pre><p>示例</p><p>MATCH (e:Employee) RETURN e<br>或</p><p>MATCH (dept: Dept)<br>RETURN dept.deptno,dept.dname,dept.location</p><h5 id="4-关系基础"><a href="#4-关系基础" class="headerlink" title="4.关系基础"></a>4.关系基础</h5><p>Neo4j图数据库遵循属性图模型来存储和管理其数据。</p><p>根据属性图模型，关系应该是定向的。 否则，Neo4j将抛出一个错误消息。</p><p>基于方向性，Neo4j关系被分为两种主要类型。</p><p>单向关系<br>双向关系<br>使用新节点创建关系</p><p>示例</p><p>CREATE (e:Employee)-[r:DemoRelation]-&gt;(c:Employee)<br>这句会创建节点e，节点c，以及e -&gt; c的关系r，这里需要注意方向，比如双向是</p><p>CREATE (e:Employee)&lt;-[r:DemoRelation]-&gt;(c:Employee)<br>使用已知节点创建带属性的关系：</p><pre><code class="shell">MATCH (&lt;node1-label-name&gt;:&lt;node1-name&gt;),(&lt;node2-label-name&gt;:&lt;node2-name&gt;)CREATE      (&lt;node1-label-name&gt;)-[&lt;relationship-label-name&gt;:&lt;relationship-name&gt;    {&lt;define-properties-list&gt;}]-&gt;(&lt;node2-label-name&gt;)RETURN &lt;relationship-label-name&gt;</code></pre><p> 还是一系列键值对</p><p>示例</p><pre><code class="shell">MATCH (cust:Customer),(cc:CreditCard) CREATE (cust)-[r:DO_SHOPPING_WITH{shopdate:"12/12/2014",price:55000}]-&gt;(cc) RETURN r</code></pre><p>检索关系节点的详细信息：</p><pre><code class="shell">MATCH (&lt;node1-label-name&gt;)-[&lt;relationship-label-name&gt;:&lt;relationship-name&gt;]-&gt;(&lt;node2-label-name&gt;)RETURN &lt;relationship-label-name&gt;</code></pre><p>示例</p><pre><code class="shell">MATCH (cust)-[r:DO_SHOPPING_WITH]-&gt;(cc) RETURN cust,cc</code></pre><h5 id="5-WHERE子句"><a href="#5-WHERE子句" class="headerlink" title="5.WHERE子句"></a>5.WHERE子句</h5><p>像SQL一样，Neo4j CQL在CQL MATCH命令中提供了WHERE子句来过滤MATCH查询的结果。</p><p>简单WHERE子句语法</p><p>WHERE <property-name> <comparison-operator> <value><br>语法说明：</value></comparison-operator></property-name></p><table><thead><tr><th>No.</th><th style="text-align:center">语法元素</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">WHERE</td><td style="text-align:right">它是一个Neo4j CQL关键字。</td></tr><tr><td>2</td><td style="text-align:center">&lt;属性名称&gt;</td><td style="text-align:right">它是节点或关系的属性名称。</td></tr><tr><td>3</td><td style="text-align:center">&lt;比较运算符&gt;</td><td style="text-align:right">它是Neo4j CQL比较运算符之一。</td></tr><tr><td>4</td><td style="text-align:center">&lt;值&gt;</td><td style="text-align:right">它是一个字面值，如数字文字，字符串文字等。</td></tr></tbody></table><h6 id="Neo4j-CQL中的比较运算符"><a href="#Neo4j-CQL中的比较运算符" class="headerlink" title="Neo4j CQL中的比较运算符"></a>Neo4j CQL中的比较运算符</h6><p>Neo4j 支持以下的比较运算符，在 Neo4j CQL WHERE 子句中使用来支持条件</p><table><thead><tr><th>No.</th><th style="text-align:center">比较运算符</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>1.</td><td style="text-align:center">=</td><td style="text-align:right">它是Neo4j CQL“等于”运算符。</td></tr><tr><td>2.</td><td style="text-align:center">&lt;&gt;</td><td style="text-align:right">它是一个Neo4j CQL“不等于”运算符。</td></tr><tr><td>3.</td><td style="text-align:center">&lt;</td><td style="text-align:right">它是一个Neo4j CQL“小于”运算符。</td></tr><tr><td>4.</td><td style="text-align:center">&gt;</td><td style="text-align:right">它是一个Neo4j CQL“大于”运算符。</td></tr><tr><td>5.</td><td style="text-align:center">&lt;=</td><td style="text-align:right">它是一个Neo4j CQL“小于或等于”运算符。</td></tr><tr><td>6.</td><td style="text-align:center">=</td><td style="text-align:right">它是一个Neo4j CQL“大于或等于”运算符。</td></tr></tbody></table><p>我们可以使用布尔运算符在同一命令上放置多个条件。</p><h6 id="Neo4j-CQL中的布尔运算符"><a href="#Neo4j-CQL中的布尔运算符" class="headerlink" title="Neo4j CQL中的布尔运算符"></a>Neo4j CQL中的布尔运算符</h6><p>Neo4j支持以下布尔运算符在Neo4j CQL WHERE子句中使用以支持多个条件。</p><table><thead><tr><th>No.</th><th style="text-align:center">布尔运算符</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">AND</td><td style="text-align:right">它是一个支持AND操作的Neo4j CQL关键字。</td></tr><tr><td>2</td><td style="text-align:center">OR</td><td style="text-align:right">它是一个Neo4j CQL关键字来支持OR操作。</td></tr><tr><td>3</td><td style="text-align:center">NOT</td><td style="text-align:right">它是一个Neo4j CQL关键字支持NOT操作。</td></tr><tr><td>4</td><td style="text-align:center">XOR</td><td style="text-align:right">它是一个支持XOR操作的Neo4j CQL关键字。</td></tr></tbody></table><p>示例</p><p>MATCH (emp:Employee)<br>WHERE emp.name = ‘Abc’ OR emp.name = ‘Xyz’<br>RETURN emp</p><p>利用WHERE创建指定关系节点：</p><p>MATCH (cust:Customer),(cc:CreditCard)<br>WHERE cust.id = “1001” AND cc.id= “5001”<br>CREATE (cust)-[r:DO_SHOPPING_WITH{shopdate:”12/12/2014”,price:55000}]-&gt;(cc)<br>RETURN r<br>有必要补充一下，可以不使用WHERE达到WHERE的一些效果，比如</p><p>MATCH p=(m:Bot{id:123})&lt;-[:BotRelation]-&gt;(:Bot)  RETURN p</p><h5 id="6-DELETE删除"><a href="#6-DELETE删除" class="headerlink" title="6.DELETE删除"></a>6.DELETE删除</h5><p>Neo4j使用CQL DELETE子句</p><p>删除节点。<br>删除节点及相关节点和关系。<br>DELETE节点子句语法</p><p>DELETE <node-name-list><br>示例</node-name-list></p><p>MATCH (e: Employee) DELETE e<br>DELETE节点和关系子句语法</p><p>DELETE <node1-name>,<node2-name>,<relationship-name><br>示例</relationship-name></node2-name></node1-name></p><p>MATCH (cc: CreditCard)-[rel]-(c:Customer)<br>DELETE cc,c,rel</p><h5 id="7-REMOVE删除"><a href="#7-REMOVE删除" class="headerlink" title="7.REMOVE删除"></a>7.REMOVE删除</h5><p>有时基于我们的客户端要求，我们需要向现有节点或关系添加或删除属性。</p><p>我们使用Neo4j CQL SET子句向现有节点或关系添加新属性。</p><p>我们使用Neo4j CQL REMOVE子句来删除节点或关系的现有属性。</p><p>Neo4j CQL REMOVE命令用于</p><p>删除节点或关系的标签<br>删除节点或关系的属性<br>Neo4j CQL DELETE和REMOVE命令之间的主要区别 -</p><p>DELETE操作用于删除节点和关联关系。<br>REMOVE操作用于删除标签和属性。<br>Neo4j CQL DELETE和REMOVE命令之间的相似性 -</p><p>这两个命令不应单独使用。<br>两个命令都应该与MATCH命令一起使用。</p><h6 id="1-REMOVE属性子句语法"><a href="#1-REMOVE属性子句语法" class="headerlink" title="1.REMOVE属性子句语法"></a>1.REMOVE属性子句语法</h6><p>REMOVE <code>&lt;node-name&gt;.&lt;property1-name&gt;,&lt;node-name&gt;.&lt;property2-name&gt;</code></p><p>语法说明：</p><ul><li>node-name 它是节点的名称。</li><li>property1-name 它是节点的属性名称。</li></ul><p>示例</p><p>MATCH (dc:DebitCard)<br>REMOVE dc.cvv<br>RETURN dc</p><h6 id="2-REMOVE一个Label子句语法："><a href="#2-REMOVE一个Label子句语法：" class="headerlink" title="2.REMOVE一个Label子句语法："></a>2.REMOVE一个Label子句语法：</h6><p>REMOVE <code>&lt;label-name-list&gt;</code></p><p>2.它是一个标签列表，用于永久性地从节点或关系中删除它。<br>语法</p><p><code>&lt; node-name &gt;:&lt; label2-name &gt;, .... &lt; node-name &gt;:&lt; labeln-name &gt;</code> </p><p>示例</p><p>1.我们创建一个含有两个标签的节点：</p><p>CREATE (m:Movie:Pic)<br>2.查询该节点</p><p>MATCH (n:Movie) RETURN n</p><p>3.删除标签</p><p>MATCH (m:Movie)<br>REMOVE m:Pic<br>4.再次查询 </p><h5 id="8-SET子句"><a href="#8-SET子句" class="headerlink" title="8.SET子句"></a>8.SET子句</h5><p>有时，根据我们的客户端要求，我们需要向现有节点或关系添加新属性。</p><p>要做到这一点，Neo4j CQL提供了一个SET子句。</p><p>Neo4j CQL已提供SET子句来执行以下操作。</p><p>向现有节点或关系添加新属性<br>添加或更新属性值<br>SET子句语法</p><p>SET <code>&lt;node-label-name&gt;.&lt;property1-name&gt;,...&lt;node-laben-name&gt;.&lt;propertyn-name&gt;</code><br>语法说明：</p><ul><li>node-label-name <code>&lt;节点标签名称&gt;</code>这是一个节点的标签名称。</li><li>property1-name <code>&lt;属性名称&gt;</code> 它是一个节点的属性名。</li></ul><p>示例</p><p>MATCH (dc:DebitCard)<br>SET dc.atm_pin = 3456<br>RETURN dc</p><h5 id="9-ORDER-BY排序"><a href="#9-ORDER-BY排序" class="headerlink" title="9.ORDER BY排序"></a>9.ORDER BY排序</h5><p>Neo4j CQL ORDER BY子句</p><p>Neo4j CQL在MATCH命令中提供了“ORDER BY”子句，对MATCH查询返回的结果进行排序。</p><p>我们可以按升序或降序对行进行排序。</p><p>默认情况下，它按升序对行进行排序。 如果我们要按降序对它们进行排序，我们需要使用DESC子句。</p><p>ORDER BY子句语法</p><p>ORDER BY <code>&lt;property-name-list&gt;  [DESC]</code><br>语法：</p><p><code>&lt;node-label-name&gt;.&lt;property1-name&gt;,</code><br><code>&lt;node-label-name&gt;.&lt;property2-name&gt;,</code><br><code>....</code><br><code>&lt;node-label-name&gt;.&lt;propertyn-name&gt;</code></p><ul><li>node-label-name 它是节点的标签名称。</li><li>property1-name  它是节点的属性名称。</li></ul><p>示例</p><p>MATCH (emp:Employee)<br>RETURN emp.empid,emp.name,emp.salary,emp.deptno<br>ORDER BY emp.name<br>10.UNION子句<br>与SQL一样，Neo4j CQL有两个子句，将两个不同的结果合并成一组结果</p><p>UNION<br>UNION ALL<br>UNION子句</p><p>它将两组结果中的公共行组合并返回到一组结果中。 它不从两个节点返回重复的行。</p><p>限制：</p><p>结果列类型和来自两组结果的名称必须匹配，这意味着列名称应该相同，列的数据类型应该相同。</p><h5 id="10-UNION子句语法"><a href="#10-UNION子句语法" class="headerlink" title="10 UNION子句语法"></a>10 UNION子句语法</h5><p><code>&lt;MATCH Command1&gt;</code><br> <code>UNION</code><br><code>&lt;MATCH Command2&gt;</code></p><p>注意 -</p><p>如果这两个查询不返回相同的列名和数据类型，那么它抛出一个错误。</p><p>示例</p><p>MATCH (cc:CreditCard) RETURN cc.id,cc.number<br>UNION<br>MATCH (dc:DebitCard) RETURN dc.id,dc.number<br>UNION ALL子句</p><p>它结合并返回两个结果集的所有行成一个单一的结果集。它还返回由两个节点重复行。</p><p>限制</p><p>结果列类型，并从两个结果集的名字必须匹配，这意味着列名称应该是相同的，列的数据类型应该是相同的。</p><h6 id="UNION-ALL子句语法"><a href="#UNION-ALL子句语法" class="headerlink" title="UNION ALL子句语法"></a>UNION ALL子句语法</h6><p><code>&lt;MATCH Command1&gt;</code><br><code>UNION ALL</code><br><code>&lt;MATCH Command2&gt;</code><br>示例</p><p>MATCH (cc:CreditCard) RETURN cc.id,cc.number<br>UNION ALL<br>MATCH (dc:DebitCard) RETURN dc.id,dc.number</p><h5 id="11-LIMIT和SKIP子句"><a href="#11-LIMIT和SKIP子句" class="headerlink" title="11.LIMIT和SKIP子句"></a>11.LIMIT和SKIP子句</h5><p>Neo4j CQL已提供LIMIT子句和SKIP来过滤或限制查询返回的行数。</p><p>简单来说：LIMIT返回前几行，SKIP返回后几行。</p><p>LIMIT 示例</p><p>MATCH (emp:Employee)<br>RETURN emp<br>LIMIT 2<br>它只返回Top的两个结果，因为我们定义了limit = 2。这意味着前两行。</p><p>SKIP示例</p><p>MATCH (emp:Employee)<br>RETURN emp<br>SKIP 2<br>它只返回来自Bottom的两个结果，因为我们定义了skip = 2。这意味着最后两行。</p><h5 id="12-MERGE命令"><a href="#12-MERGE命令" class="headerlink" title="12.MERGE命令"></a>12.MERGE命令</h5><p>Neo4j使用CQL MERGE命令 -</p><p>创建节点，关系和属性<br>为从数据库检索数据<br>MERGE命令是CREATE命令和MATCH命令的组合。</p><p>MERGE = CREATE + MATCH<br>Neo4j CQL MERGE命令在图中搜索给定模式，如果存在，则返回结果</p><p>如果它不存在于图中，则它创建新的节点/关系并返回结果。</p><p>Neo4j CQL MERGE语法</p><p>MERGE <code>(&lt;node-name&gt;:&lt;label-name&gt;</code><br>{<br>   <code>&lt;key&gt;:&lt;1-Value&gt;</code><br>   …..<br>   <code>&lt;n-key&gt;:&lt;n-Value&gt;</code><br>})<br>注意 -</p><p>Neo4j CQL MERGE命令语法与CQL CREATE命令类似。</p><p>我们将使用这两个命令执行以下操作 -</p><p>创建具有一个属性的配置文件节点：Id，名称<br>创建具有相同属性的同一个Profile节点：Id，Name<br>检索所有Profile节点详细信息并观察结果<br>我们将使用CREATE命令执行这些操作：</p><p>MERGE (gp2:GoogleProfile2{ Id: 201402,Name:”Nokia”})<br>MERGE (gp2:GoogleProfile2{ Id: 201402,Name:”Nokia”})<br>MATCH  (gp1:GoogleProfile1)<br>RETURN gp1.Id,gp1.Name<br>如果我们观察上面的查询结果，它只显示一行，因为CQL MERGE命令检查该节点在数据库中是否可用。 如果它不存在，它创建新节点。 否则，它不创建新的。</p><p>通过观察这些结果，我们可以说，CQL MERGE命令将新的节点添加到数据库，只有当它不存在。</p><h5 id="13-NULL值"><a href="#13-NULL值" class="headerlink" title="13.NULL值"></a>13.NULL值</h5><p>Neo4j CQL将空值视为对节点或关系的属性的缺失值或未定义值。</p><p>当我们创建一个具有现有节点标签名称但未指定其属性值的节点时，它将创建一个具有NULL属性值的新节点。</p><p>让我们用一个例子来看这个。</p><p>MATCH (e:Employee)<br>WHERE e.id IS NOT NULL<br>RETURN e.id,e.name,e.sal,e.deptno<br>提供了一个WHERE子句来过滤该行，即Id属性不应该包含NULL值。</p><p>MATCH (e:Employee)<br>WHERE e.id IS NULL<br>RETURN e.id,e.name,e.sal,e.deptno<br>这里我们使用IS操作符来仅返回NULL行。</p><h5 id="14-IN操作符"><a href="#14-IN操作符" class="headerlink" title="14.IN操作符"></a>14.IN操作符</h5><p>与SQL一样，Neo4j CQL提供了一个IN运算符，以便为CQL命令提供值的集合。</p><p>IN操作符语法</p><p>IN[<code>&lt;Collection-of-values&gt;</code>]<br>它是由逗号运算符分隔的值的集合。</p><p>示例</p><p>MATCH (e:Employee)<br>WHERE e.id IN [123,124]<br>RETURN e.id,e.name,e.sal,e.deptno</p><h5 id="15-INDEX索引"><a href="#15-INDEX索引" class="headerlink" title="15.INDEX索引"></a>15.INDEX索引</h5><p>Neo4j SQL支持节点或关系属性上的索引，以提高应用程序的性能。</p><p>我们可以为具有相同标签名称的所有节点的属性创建索引。</p><p>我们可以在MATCH或WHERE或IN运算符上使用这些索引列来改进CQL Command的执行。</p><p>Neo4J索引操作</p><p>Create Index 创建索引<br>Drop Index 丢弃索引<br>我们将在本章中用示例来讨论这些操作。</p><p>创建索引的语法：</p><p>CREATE INDEX ON :<code>&lt;label_name&gt; (&lt;property_name&gt;</code>)<br>注意：-</p><p>冒号（:)运算符用于引用节点或关系标签名称。</p><p>上述语法描述它在节点或关系的的上创建一个新索引。</p><p>示例</p><p>CREATE INDEX ON :Customer (name)<br>删除索引的语法：</p><p>DROP INDEX ON :<code>&lt;label_name&gt; (&lt;property_name&gt;</code>)<br>示例</p><p>DROP INDEX ON :Customer (name)</p><h5 id="16-UNIQUE约束"><a href="#16-UNIQUE约束" class="headerlink" title="16.UNIQUE约束"></a>16.UNIQUE约束</h5><p>在Neo4j数据库中，CQL CREATE命令始终创建新的节点或关系，这意味着即使您使用相同的值，它也会插入一个新行。 根据我们对某些节点或关系的应用需求，我们必须避免这种重复。 然后我们不能直接得到这个。 我们应该使用一些数据库约束来创建节点或关系的一个或多个属性的规则。</p><p>像SQL一样，Neo4j数据库也支持对NODE或Relationship的属性的UNIQUE约束</p><p>UNIQUE约束的优点</p><p>避免重复记录。<br>强制执行数据完整性规则<br>创建唯一约束语法</p><p>CREATE CONSTRAINT ON (&lt;label_name&gt;)<br>ASSERT &lt;property_name&gt; IS UNIQUE<br>语法说明：</p><table><thead><tr><th>No.</th><th style="text-align:center">语法元素</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>1。</td><td style="text-align:center">CREATE CONSTRAINT ON</td><td style="text-align:right">它是一个Neo4j CQL关键字。</td></tr><tr><td>2。</td><td style="text-align:center">label_name</td><td style="text-align:right">它是节点或关系的标签名称。</td></tr><tr><td>3。</td><td style="text-align:center">ASSERT</td><td style="text-align:right">它是一个Neo4j CQL关键字。</td></tr><tr><td>4。</td><td style="text-align:center">property_name</td><td style="text-align:right">它是节点或关系的属性名称。</td></tr><tr><td>5。</td><td style="text-align:center">IS UNIQUE</td><td style="text-align:right">它是一个Neo4j CQL关键字，通知Neo4j数据库服务器创建一个唯一约束。</td></tr></tbody></table><p>注意：-</p><p>上述语法描述了只需要 节点或关系就可以创造一个独特的约束。</p><p>示例</p><p>CREATE CONSTRAINT ON (cc:CreditCard)<br>ASSERT cc.number IS UNIQUE<br>注意</p><p>如果创建约束时节点属性有重复值，Neo4j DB服务器将会抛出一个错误，表示无法创建。</p><p>删除UNIQUE约束语法：</p><p>DROP CONSTRAINT ON (&lt;label_name&gt;)<br>ASSERT &lt;property_name&gt; IS UNIQUE<br>示例</p><p>DROP CONSTRAINT ON (cc:CreditCard)<br>ASSERT cc.number IS UNIQUE<br>17.DISTINCT独特<br>这个函数的用法就像SQL中的distinct关键字，返回的是所有不同值。</p><p>示例 </p><p>MATCH (n:Movie) RETURN Distinct(n.name)</p><h4 id="第五章：管理员-数据备份-恢复"><a href="#第五章：管理员-数据备份-恢复" class="headerlink" title="第五章：管理员 数据备份/恢复"></a>第五章：管理员 数据备份/恢复</h4><h5 id="1-数据库备份"><a href="#1-数据库备份" class="headerlink" title="1.数据库备份"></a>1.数据库备份</h5><p>在对Neo4j数据进行备份、还原、迁移的操作时，首先要关闭neo4j;</p><p>cd %NEO4J_HOME%/bin<br>./neo4j stop<br>数据备份到文件</p><p>./neo4j-admin  dump –database=graph.db –to=/home/2018.dump<br>之后，进行数据还原，将生成的存储文件拷贝到另一个相同版本的环境中。</p><h5 id="2-数据库恢复"><a href="#2-数据库恢复" class="headerlink" title="2.数据库恢复"></a>2.数据库恢复</h5><p>还原、迁移之前 ，关闭neo4j服务。操作同上；</p><p>数据导入：</p><p>./neo4j-admin load –from=/home/2016-10-02.dump –database=graph.db –force<br>重启服务：</p><p>./neo4j start</p><p>  参考 <code>https://cloud.tencent.com/developer/article/1336299</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;第一章：介绍&quot;&gt;&lt;a href=&quot;#第一章：介绍&quot; class=&quot;headerlink&quot; title=&quot;第一章：介绍&quot;&gt;&lt;/a&gt;第一章：介绍&lt;/h4&gt;&lt;h5 id=&quot;Neo4j是什么&quot;&gt;&lt;a href=&quot;#Neo4j是什么&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="neo4j" scheme="https://blog.gitee.io/tags/neo4j/"/>
    
  </entry>
  
  <entry>
    <title>thymeleaf自定义dialect</title>
    <link href="https://blog.gitee.io/2019/07/22/custom-thymeleaf-dealect/"/>
    <id>https://blog.gitee.io/2019/07/22/custom-thymeleaf-dealect/</id>
    <published>2019-07-21T16:00:00.000Z</published>
    <updated>2019-07-22T08:57:26.950Z</updated>
    
    <content type="html"><![CDATA[<p>有时候<code>thymeleaf</code>自带的模板方言有点不够用的时候 可以支持自定义，最近遇到一个在<code>thymeleaf</code>模板中显示订单状态的需求。<br>当然也可以使用 <code>switch case</code>的方式,但是如果很多的页面都要使用的时候你得一直复制代码 很麻烦 而且中途如果修改了某个状态码含义 你得全部修改一遍。这当然不是我们得正确使用姿势。状态码含义如下</p><p>9 待支付定金<br>10 待停车(已支付定金)<br>11 停车中<br>12 停车结束(待支付尾款)<br>13 订单完成(已支付尾款)</p><h4 id="定义处理tag得解析器"><a href="#定义处理tag得解析器" class="headerlink" title="定义处理tag得解析器"></a>定义处理tag得解析器</h4><p> 这里我们定义一个名为<code>orderstatus</code>的属性(attributeName),表示遇到这个属性会调用doProcess方法中的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkingOrderStatusTagProcessor</span>  <span class="keyword">extends</span> <span class="title">AbstractAttributeTagProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ParkingOrderStatusTagProcessor</span><span class="params">(String dialectPrefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(TemplateMode.HTML, dialectPrefix,</span><br><span class="line"><span class="keyword">null</span>, <span class="keyword">false</span>, <span class="string">"orderstatus"</span>, <span class="keyword">true</span>, <span class="number">1000</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doProcess</span><span class="params">(ITemplateContext context, IProcessableElementTag tag,</span></span></span><br><span class="line"><span class="function"><span class="params">AttributeName attributeName, String attributeValue,</span></span></span><br><span class="line"><span class="function"><span class="params">IElementTagStructureHandler structureHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> IStandardExpressionParser expressionParser = StandardExpressions</span><br><span class="line">                .getExpressionParser(context.getConfiguration());</span><br><span class="line">        <span class="keyword">final</span> IStandardExpression expression = </span><br><span class="line">expressionParser.parseExpression(context, attributeValue);</span><br><span class="line">        Object val=expression.execute(context);</span><br><span class="line">        <span class="keyword">if</span>(val!=<span class="keyword">null</span> &amp;&amp; val <span class="keyword">instanceof</span> Number)&#123;</span><br><span class="line">            structureHandler.setBody(</span><br><span class="line">              HtmlEscape.escapeHtml5(getOrderStatus((Integer) val)), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getOrderStatus</span><span class="params">(Integer status)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(status== <span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"待支付定金"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(status==<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"待停车(已支付定金)"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(status==<span class="number">11</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"停车中"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(status==<span class="number">12</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"停车结束(待支付尾款)"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(status==<span class="number">13</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"订单完成(已支付尾款)"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"未知状态"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义方言"><a href="#定义方言" class="headerlink" title="定义方言"></a>定义方言</h4><p> 创建一个方言 因为<code>thymeleaf</code>模板引擎需要先添加方言(<code>Dealect</code>),而这个方言中又可以添加多个tag属性解析器,这里设置了一个名为<code>park</code>的前缀，并添加了上面的<code>ParkingOrderStatusTagProcessor</code>属性解析器。</p><p> 在模板中就可以使用<code>&lt;div park:orderstatus=&quot;${order.status}&quot;&gt;&lt;/div&gt;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkDealect</span> <span class="keyword">extends</span> <span class="title">AbstractProcessorDialect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ParkDealect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="string">"parkingDealect"</span>, <span class="string">"park"</span>, <span class="number">1001</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;IProcessor&gt; <span class="title">getProcessors</span><span class="params">(String dialectPrefix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Set&lt;IProcessor&gt; processors = <span class="keyword">new</span> HashSet&lt;IProcessor&gt;();</span><br><span class="line">processors.add(<span class="keyword">new</span> ParkingOrderStatusTagProcessor(dialectPrefix));</span><br><span class="line"><span class="keyword">return</span> processors;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加方言到模板引擎中"><a href="#添加方言到模板引擎中" class="headerlink" title="添加方言到模板引擎中"></a>添加方言到模板引擎中</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">(@Autowired ITemplateResolver resolver)</span></span>&#123;</span><br><span class="line">    SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">    templateEngine.setEnableSpringELCompiler(<span class="keyword">true</span>);</span><br><span class="line">    templateEngine.setTemplateResolver(resolver);</span><br><span class="line">    templateEngine.addDialect(<span class="keyword">new</span> ParkDealect());<span class="comment">//把定义好的方言添加进去</span></span><br><span class="line">    <span class="keyword">return</span> templateEngine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最后在模板中设置一下park的xmlns,我自己测试了一下 这个xmlns的文件不创建也没关系，但最好还是建好。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:park</span>=<span class="string">"http://www.peachyy.com/thymeleaf/park"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实自定义方言就相当于JSP中的自定义标签。更多xmlns文件的细节后面在更新了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候&lt;code&gt;thymeleaf&lt;/code&gt;自带的模板方言有点不够用的时候 可以支持自定义，最近遇到一个在&lt;code&gt;thymeleaf&lt;/code&gt;模板中显示订单状态的需求。&lt;br&gt;当然也可以使用 &lt;code&gt;switch case&lt;/code&gt;的方式,但是如果很多
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="thymeleaf" scheme="https://blog.gitee.io/tags/thymeleaf/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch中短语匹配match_phrase</title>
    <link href="https://blog.gitee.io/2019/05/07/es-match-phrase/"/>
    <id>https://blog.gitee.io/2019/05/07/es-match-phrase/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2019-05-07T09:56:25.367Z</updated>
    
    <content type="html"><![CDATA[<p> 现有业务中很少用到<code>match_phrase</code>这个搜索，最近在实现基于<code>elasticsearch</code>的日志搜集 并自助告警一个业务，因为日志的不规范 所以需要用到对某个日志短语进行搜索，不能像match做全文检索。</p><p> 比如需要精确寻找日志中的<code>请求第三方CAKA服务器失败</code> </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /filebeat*/_search</span><br><span class="line">&#123;</span><br><span class="line">"query": &#123;</span><br><span class="line">        "match_phrase": &#123;</span><br><span class="line">            "message": "请求第三方CAKA服务器失败" </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询结果中就完全包含了这句短语。不会进行分词搜索。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 现有业务中很少用到&lt;code&gt;match_phrase&lt;/code&gt;这个搜索，最近在实现基于&lt;code&gt;elasticsearch&lt;/code&gt;的日志搜集 并自助告警一个业务，因为日志的不规范 所以需要用到对某个日志短语进行搜索，不能像match做全文检索。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="elasticsearch" scheme="https://blog.gitee.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>认识go语言与环境搭建</title>
    <link href="https://blog.gitee.io/2019/03/26/go_install/"/>
    <id>https://blog.gitee.io/2019/03/26/go_install/</id>
    <published>2019-03-25T16:00:00.000Z</published>
    <updated>2019-03-26T04:00:23.714Z</updated>
    
    <content type="html"><![CDATA[<p> go编程语言是一个由Google开源的编程语言项目，它具有很强的表达能力、简洁高效，对并发特别友好，它是一个快速的、静态类型的编译型语言，感觉却像动态类型的解释型语言。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装一般可以选择源码安装、官方提供的可执行文件安装，一般在不修改源码的情况话 直接选择下载官方提供的可执行文件或者直接下载二进制压缩包安装即可。</p><h5 id="window"><a href="#window" class="headerlink" title="window"></a>window</h5><p>  如果是可执行文件安装方式 引导用户安装成功的 会自动配置好go的环境变量 在命令行输入<code>go</code> 就能看到go命令行的帮助提示。</p><p>  解压二进制文件安装方式 需要手动配置好go环境变量 运行go命令如下</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go</span><br><span class="line">Go is a<span class="built_in"> tool </span><span class="keyword">for</span> managing Go source code.</span><br><span class="line">Usage:</span><br><span class="line">        go &lt;command&gt; [arguments]</span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">        bug         start a bug report</span><br><span class="line">        build       compile packages <span class="keyword">and</span> dependencies</span><br><span class="line">        clean       <span class="builtin-name">remove</span> object files <span class="keyword">and</span> cached files</span><br><span class="line">        doc         show documentation <span class="keyword">for</span> package <span class="keyword">or</span> symbol</span><br><span class="line">        env         <span class="builtin-name">print</span> Go environment information</span><br><span class="line">        fix         update packages <span class="keyword">to</span> use new APIs</span><br><span class="line">        fmt         gofmt (reformat) package sources</span><br><span class="line">        generate    generate Go files by processing source</span><br><span class="line">        <span class="builtin-name">get</span>         download <span class="keyword">and</span> install packages <span class="keyword">and</span> dependencies</span><br><span class="line">        install     compile <span class="keyword">and</span> install packages <span class="keyword">and</span> dependencies</span><br><span class="line">        list        list packages <span class="keyword">or</span> modules</span><br><span class="line">        mod         module maintenance</span><br><span class="line">        <span class="builtin-name">run</span>         compile <span class="keyword">and</span> <span class="builtin-name">run</span> Go program</span><br><span class="line">        test        test packages</span><br><span class="line">       <span class="built_in"> tool </span>       <span class="builtin-name">run</span> specified go tool</span><br><span class="line">        version     <span class="builtin-name">print</span> Go version</span><br><span class="line">        vet         report likely mistakes <span class="keyword">in</span> packages</span><br></pre></td></tr></table></figure><h5 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h5><p> linux系统 下载并解压二进制之后需要手动设置go的环境变量 如go文件解压到目录<code>/usr/local/go</code></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOROOT</span>=/usr/local/go</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$GOROOT/bin</span><br></pre></td></tr></table></figure><p>此时就能使用go命令 看到帮助提示 说明安装成功。</p><h4 id="命令行认识"><a href="#命令行认识" class="headerlink" title="命令行认识"></a>命令行认识</h4><ul><li>go get 从远程下载package 需要安装与远程包匹配的代码管理工具，如 Git、SVN、HG 等</li><li>go run 运行go文件</li><li>go build 编译go文件 如果代码有误或者语法不正确会报错</li><li>go fmt    格式化代码格式</li><li>go install 编码包文件和整个程序</li><li>go test 运行测试文件 go语言中 <code>xxx_test.go</code> 以下划线test.go结束的文件名为测试文件</li><li>go doc  文件查看</li><li><p>go clean 删除缓存文件</p><p><code>godoc -http=:6060</code> 可在本地启动一个文档服务器 和官方网站的一样哦，方便网络不好的情况下在本地浏览器打开<a href="http://localhost:6060" target="_blank" rel="noopener">http://localhost:6060</a> 就能浏览文档。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; go编程语言是一个由Google开源的编程语言项目，它具有很强的表达能力、简洁高效，对并发特别友好，它是一个快速的、静态类型的编译型语言，感觉却像动态类型的解释型语言。&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://blog.gitee.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="go" scheme="https://blog.gitee.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>再见2018 再见昨天</title>
    <link href="https://blog.gitee.io/2019/01/15/todo2018/"/>
    <id>https://blog.gitee.io/2019/01/15/todo2018/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-01-15T08:49:51.146Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>自己逼自己回首一下过往 实在写不出东西来了  那么就随便写点流水账啦 ^_^</code></p><p>  <img src="//static.1.seoui.com/images/2019/01/1.jpg" alt=""></p><p>  2018年真滴过完啦 这一切似乎就在昨天、所有的景象就在眼前，今年是很特别的一年 因为在这一年完成了人生中的大事有那么几件。<br>  <a id="more"></a><br>  这是在雾都(重庆)的第9个年头了 依稀记得刚来的时候和几个兄弟伙朝夕挤在一张不足1.5米宽的床上，没日没夜玩着电脑游戏，就连白天饭都顾不上吃 晚上只能去楼下夜市买冒菜吃，这种日子过得轻松(邋遢)了点，但是确实过得很开心 无忧无虑 自由自在的，可惜呀 再也回不去了。</p><p>  后来工作了，每天都是早出晚归的，上班下班，忙得事情可多了，本身干这一行过得相当无趣，有那么一段时间甚至觉得都得了抑郁症了，比较有意义的是每天都会研究或者发明一些小玩意，当然不限于小软件之类的东西，以至于坚持到了现在，陆陆续续的换掉了几份工作 总体来说还是跟着自己的意向在进步，在这段时光里机缘巧合的情况下 遇到了我心爱老婆(也就是前女友)，是她让我在这个冰冷的城市有了归宿感，也是她让我有了努力的理由，虽然我们的日子过得很平凡，但是内心多了一份踏实和牵挂，在我们的共同努力下也装修好了我们的第一套房屋，也算是暂时告别了租房生涯啦！上帝把时间同时共享给了世间的每一个人，我们在一天天的变老，有的亲人也在一天天离开我们，每次回到老家总觉得少点什么。</p><p>  这一年是到目前为止 技术生涯最颓废的一年，就像我以前一个同事(庚)说的，一直在“吃老本”，可能这也是技术人的一个通病，基本上我的工作上已经不涉及前端了，想想之前唯一能吹就是前端了，没想到计划不如变化 竟然…。不过虽然没有专门研究前端了，但是我却收获到了其他的领域的东西，最后还是夸一下自己吧  通过这几年的历程，终究还是能够把自己养得一般般~~ 不畏过去不畏将来^_^。</p><p>  最后18年没有太多想说的了，时常多陪陪亲人朋友 毕竟人生只有这么短短几十年。 希望大家都身体/心理健康、每天多开心一点，其次再是努力生活，努力工作，努力玩！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;code&gt;自己逼自己回首一下过往 实在写不出东西来了  那么就随便写点流水账啦 ^_^&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;//static.1.seoui.com/images/2019/01/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  2018年真滴过完啦 这一切似乎就在昨天、所有的景象就在眼前，今年是很特别的一年 因为在这一年完成了人生中的大事有那么几件。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://blog.gitee.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://blog.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>svn版本控制迁移到git</title>
    <link href="https://blog.gitee.io/2018/11/27/svnToGit/"/>
    <id>https://blog.gitee.io/2018/11/27/svnToGit/</id>
    <published>2018-11-26T16:00:00.000Z</published>
    <updated>2018-11-27T08:53:54.194Z</updated>
    
    <content type="html"><![CDATA[<h4 id="获得原-SVN-仓库使用的作者名字列表"><a href="#获得原-SVN-仓库使用的作者名字列表" class="headerlink" title="获得原 SVN 仓库使用的作者名字列表"></a>获得原 SVN 仓库使用的作者名字列表</h4><p> 因为导入到git需要配置原作者(svn提交人)和git账户的映射关系 其格式为：</p><p> <code>vim authors-transform.txt</code></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">taoxs = xsTao &lt;xsTao@xxx.com&gt;</span><br><span class="line">lh1 = lh1 &lt;lhl@xxx.com&gt;</span><br></pre></td></tr></table></figure><h4 id="利用-git-svn-克隆-SVN-仓库"><a href="#利用-git-svn-克隆-SVN-仓库" class="headerlink" title="利用 git svn 克隆 SVN 仓库"></a>利用 git svn 克隆 SVN 仓库</h4><p> 新建一个目录作为 Git 项目的根目标，并进入到该目录中，把前面创建的<code>authors-transform.txt</code>用户映射关系复制到这个目录中，执行下面的命令：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git svn clone $&#123;SVN REP URL &#125; --no-metadata -A authors-transform.txt</span><br></pre></td></tr></table></figure><p>如果SVN的体积/文件有点大得话，那么该过程会持续较长时间。耐心等待</p><p>执行完成后基本上就OK了，把SVN版本库搬到git上来了，但是这个时候还需要提交到远程仓库</p><h4 id="提交GIT版本库到远程仓库"><a href="#提交GIT版本库到远程仓库" class="headerlink" title="提交GIT版本库到远程仓库"></a>提交GIT版本库到远程仓库</h4><p>进入刚刚生成的版本库中 用下面的命令查看分支列表 有不需要的可以删除</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git show-ref</span><br></pre></td></tr></table></figure><p>将refs/remotes 下剩余的引用移动为本地分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -Rf .git/refs/remotes/* .git/refs/heads/</span><br><span class="line">rm -Rf .git/refs/remotes</span><br></pre></td></tr></table></figure><p>为本地仓库添加远程仓库地址 就可以commit/push了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin ''http://192.168.1.3:8090/osTeam/test.git'</span><br></pre></td></tr></table></figure><p>现在就完美从SVN迁移到GIT了 并保留了原SVN的提交版本记录信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;获得原-SVN-仓库使用的作者名字列表&quot;&gt;&lt;a href=&quot;#获得原-SVN-仓库使用的作者名字列表&quot; class=&quot;headerlink&quot; title=&quot;获得原 SVN 仓库使用的作者名字列表&quot;&gt;&lt;/a&gt;获得原 SVN 仓库使用的作者名字列表&lt;/h4&gt;&lt;p&gt; 因
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="svn" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/svn/"/>
    
      <category term="git" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/svn/git/"/>
    
    
      <category term="svn" scheme="https://blog.gitee.io/tags/svn/"/>
    
      <category term="git" scheme="https://blog.gitee.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>让mysql支持emoji表情</title>
    <link href="https://blog.gitee.io/2018/10/22/mysql_emoji_support/"/>
    <id>https://blog.gitee.io/2018/10/22/mysql_emoji_support/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-22T04:40:13.613Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是emoji"><a href="#什么是emoji" class="headerlink" title="什么是emoji"></a>什么是emoji</h4><p>  emoji就是表情符号 emoji的创造者是日本人栗田穰崇(Shigetaka Kurita)</p><p>在数据库的编码不为<code>utf8mb4</code>，利用java mysql驱动保存含有表情符号的数据会出现异常<code>java.sql.SQLException: Incorrect string value: &#39;\xF0\x9F\x94\xA5&#39; for column</code></p><h4 id="mysql中存储emoji表情符号"><a href="#mysql中存储emoji表情符号" class="headerlink" title="mysql中存储emoji表情符号"></a>mysql中存储emoji表情符号</h4><p>  以前做应用软件的时候 通常把<code>mysql</code>的字符编码设置为<code>utf-8</code>，但是这个编码却不支持<code>emoji</code>表情 是因为<code>utf-8</code>编码的一个字符最多只能存储3个字节，但一个emoji表情为4个字节，所以utf8不支持存储emoji表情。</p><p>  mysql中的<code>utf8mb4</code>却能支持<code>emoji</code>表情符号 所以我们只需要更改mysql的数据库编码格式为<code>utf8mb4</code>就能支持了。<em>当然了表和字段也需要是这个编码的，在不手动设置表/字段编码的情况下，会默认继承数据库的编码格式</em>。如果手动修改为字段或者表的编码 也需要手动把表和字段修改为<code>utf8mb4</code></p><h4 id="物理机安装的数据库数据字符编码修改方式"><a href="#物理机安装的数据库数据字符编码修改方式" class="headerlink" title="物理机安装的数据库数据字符编码修改方式"></a>物理机安装的数据库数据字符编码修改方式</h4><p>修改<code>mysql</code>的配置文件<code>/etc/mysql/my.cnf</code> 并重启数据库  如果是编译安装 有可能不是这个目录噢~</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8mb4</span><br></pre></td></tr></table></figure><h4 id="云数据库-如阿里云的RDS-修改数据库编码方式"><a href="#云数据库-如阿里云的RDS-修改数据库编码方式" class="headerlink" title="云数据库 如阿里云的RDS 修改数据库编码方式"></a>云数据库 如阿里云的RDS 修改数据库编码方式</h4><p> 找到指定库的参数设置中找到<code>character_set_server</code>修改为<code>utf8mb4</code>并重启数据库</p><h4 id="客户端驱动连接的URL"><a href="#客户端驱动连接的URL" class="headerlink" title="客户端驱动连接的URL"></a>客户端驱动连接的URL</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jdbc:mysql://rr-xxxxx40.mysql.rds.aliyuncs.com:3306/db_test?useUnicode=true&amp;zeroDateTimeBehavior=convertToNull&amp;characterEncoding=utf-8</span><br></pre></td></tr></table></figure><p>这样就能在<code>mysql</code>中存储<code>emoji</code>表情符号了,<code>utf8mb4</code>是<code>utf-8</code>的超集 意味着反正<code>utf8mb4</code>也能兼容<code>utf-8</code> 在不考虑存储大小的情况下 可以直接把库设置为<code>utf8mb4</code>以免后续烦恼。</p><p>当前测试的数据版本为RDS mysql 5.6.16<br>JAVA驱动版本为5.1.30</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是emoji&quot;&gt;&lt;a href=&quot;#什么是emoji&quot; class=&quot;headerlink&quot; title=&quot;什么是emoji&quot;&gt;&lt;/a&gt;什么是emoji&lt;/h4&gt;&lt;p&gt;  emoji就是表情符号 emoji的创造者是日本人栗田穰崇(Shigetaka Kuri
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="emoji" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/emoji/"/>
    
      <category term="mysql" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/emoji/mysql/"/>
    
    
      <category term="mysql" scheme="https://blog.gitee.io/tags/mysql/"/>
    
      <category term="emoji" scheme="https://blog.gitee.io/tags/emoji/"/>
    
      <category term="mysql支持emoji表情" scheme="https://blog.gitee.io/tags/mysql%E6%94%AF%E6%8C%81emoji%E8%A1%A8%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>springCloud feign使用/优化总结</title>
    <link href="https://blog.gitee.io/2018/09/30/springcloud-feign/"/>
    <id>https://blog.gitee.io/2018/09/30/springcloud-feign/</id>
    <published>2018-09-29T16:00:00.000Z</published>
    <updated>2018-09-30T03:06:58.586Z</updated>
    
    <content type="html"><![CDATA[<p>基于springCloud Dalston.SR3版本</p><h4 id="1-当接口参数是多个的时候-需要指定-RequestParam-中的value来明确一下。"><a href="#1-当接口参数是多个的时候-需要指定-RequestParam-中的value来明确一下。" class="headerlink" title="1.当接口参数是多个的时候 需要指定@RequestParam 中的value来明确一下。"></a>1.当接口参数是多个的时候 需要指定@RequestParam 中的value来明确一下。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户互扫</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uid 被扫人ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId 当前用户ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span>(REQ_URL_PRE + <span class="string">"/qrCodeReturnUser"</span>)</span><br><span class="line"><span class="function">UserQrCode <span class="title">qrCodeReturnUser</span><span class="params">(@RequestParam(<span class="string">"uid"</span>)</span> String uid,@<span class="title">RequestParam</span><span class="params">(<span class="string">"userId"</span>)</span> Integer userId)</span>;</span><br></pre></td></tr></table></figure><h4 id="2-接口参数为对象的时候-需要使用-RequestBody注解-并采用POST方式。"><a href="#2-接口参数为对象的时候-需要使用-RequestBody注解-并采用POST方式。" class="headerlink" title="2.接口参数为对象的时候 需要使用@RequestBody注解 并采用POST方式。"></a>2.接口参数为对象的时候 需要使用@RequestBody注解 并采用POST方式。</h4><h4 id="3-如果接口是简单的数组-列表参数-这里需要使用Get请求才行"><a href="#3-如果接口是简单的数组-列表参数-这里需要使用Get请求才行" class="headerlink" title="3.如果接口是简单的数组/列表参数 这里需要使用Get请求才行"></a>3.如果接口是简单的数组/列表参数 这里需要使用Get请求才行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(REQ_URL_PRE + <span class="string">"/getUserLevels"</span>)</span><br><span class="line"><span class="function">Map&lt;Integer, UserLevel&gt; <span class="title">getUserLevels</span><span class="params">(@RequestParam(<span class="string">"userIds"</span>)</span> List&lt;Integer&gt; userIds)</span>;</span><br></pre></td></tr></table></figure><h4 id="4-直接可以在-FeignClient中配置降级处理方式-对于一些不重要的业务-自定义处理很有帮助"><a href="#4-直接可以在-FeignClient中配置降级处理方式-对于一些不重要的业务-自定义处理很有帮助" class="headerlink" title="4.直接可以在@FeignClient中配置降级处理方式 对于一些不重要的业务 自定义处理很有帮助"></a>4.直接可以在<code>@FeignClient</code>中配置降级处理方式 对于一些不重要的业务 自定义处理很有帮助</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"cloud-user"</span>, fallback = IUsers.UsersFallback.class)</span><br></pre></td></tr></table></figure><h4 id="5-feign默认只有HystrixBadRequestException异常不会走熔断，其它任何异常都会进入熔断，需要重新实现一下ErrorDecoder包装业务异常"><a href="#5-feign默认只有HystrixBadRequestException异常不会走熔断，其它任何异常都会进入熔断，需要重新实现一下ErrorDecoder包装业务异常" class="headerlink" title="5.feign默认只有HystrixBadRequestException异常不会走熔断，其它任何异常都会进入熔断，需要重新实现一下ErrorDecoder包装业务异常"></a>5.<code>feign</code>默认只有<code>HystrixBadRequestException</code>异常不会走熔断，其它任何异常都会进入熔断，需要重新实现一下<code>ErrorDecoder</code>包装业务异常</h4><p>  示例：<a href="https://github.com/peachyy/feign-support" target="_blank" rel="noopener">https://github.com/peachyy/feign-support</a></p><h4 id="6-feign-HTTP请求方式选择"><a href="#6-feign-HTTP请求方式选择" class="headerlink" title="6. feign HTTP请求方式选择"></a>6. feign HTTP请求方式选择</h4><p><code>feign</code>默认使用的是基于JDK提供的URLConnection调用HTTP接口，不具备连接池。所以资源开销上有点影响，经测试JDK的<code>URLConnection</code>比<code>Apache HttpClient</code>快很多倍。但是<code>Apache HttpClient</code>和<code>okhttp</code>都支持配置连接池功能。具体选择需要权衡</p><h4 id="7-默认不启用hystrix-需要手动指定feign-hystrix-enabled-true-开启熔断"><a href="#7-默认不启用hystrix-需要手动指定feign-hystrix-enabled-true-开启熔断" class="headerlink" title="7.默认不启用hystrix 需要手动指定feign.hystrix.enabled=true 开启熔断"></a>7.默认不启用<code>hystrix</code> 需要手动指定<code>feign.hystrix.enabled=true</code> 开启熔断</h4><h4 id="8-启用压缩也是一种有效的优化方式"><a href="#8-启用压缩也是一种有效的优化方式" class="headerlink" title="8.启用压缩也是一种有效的优化方式"></a>8.启用压缩也是一种有效的优化方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">feign.compression.request.enabled=<span class="keyword">true</span></span><br><span class="line">feign.compression.response.enabled=<span class="keyword">true</span></span><br><span class="line">feign.compression.request.mime-types=text/xml,application/xml,application/json</span><br></pre></td></tr></table></figure><h4 id="9-参数相关调优"><a href="#9-参数相关调优" class="headerlink" title="9.参数相关调优"></a>9.参数相关调优</h4><h5 id="hystrix线程数设置"><a href="#hystrix线程数设置" class="headerlink" title="hystrix线程数设置"></a>hystrix线程数设置</h5><p>设置参数<code>hystrix.threadpool.default.coreSize</code> 来指定熔断隔离的线程数 这个数需要调优，经测试 线程数我们设置为和提供方的容器线程差不多，吞吐量高许多。</p><h5 id="第一次访问服务出错的问题"><a href="#第一次访问服务出错的问题" class="headerlink" title="第一次访问服务出错的问题"></a>第一次访问服务出错的问题</h5><p>启用<code>Hystrix</code>后，很多服务当第一次访问的时候都会失败 是因为初始化负载均衡一系列操作已经超出了超时时间了 默认的超时时间为<code>1S</code>，设置参数超时时间<code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=30000</code> 可解决这个问题。</p><h5 id="负载均衡参数设置"><a href="#负载均衡参数设置" class="headerlink" title="负载均衡参数设置"></a>负载均衡参数设置</h5><p>设置了<code>Hystrix</code>的超时参数会 还需设置一下<code>ribbon</code>的相关参数  这些参数和<code>Hystrix</code>的超时参数有一定的逻辑关系<br>请求处理的超时时间 <code>ribbon.ReadTimeout=120000</code><br>请求连接的超时时间 <code>ribbon.ConnectTimeout=30000</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于springCloud Dalston.SR3版本&lt;/p&gt;
&lt;h4 id=&quot;1-当接口参数是多个的时候-需要指定-RequestParam-中的value来明确一下。&quot;&gt;&lt;a href=&quot;#1-当接口参数是多个的时候-需要指定-RequestParam-中的value来
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="springCloud" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/springCloud/"/>
    
      <category term="feign" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/springCloud/feign/"/>
    
    
      <category term="feign" scheme="https://blog.gitee.io/tags/feign/"/>
    
      <category term="springCloud" scheme="https://blog.gitee.io/tags/springCloud/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq4.x批量消息投递</title>
    <link href="https://blog.gitee.io/2018/08/02/rocketmq_batch_message/"/>
    <id>https://blog.gitee.io/2018/08/02/rocketmq_batch_message/</id>
    <published>2018-08-01T16:00:00.000Z</published>
    <updated>2018-09-06T06:21:47.891Z</updated>
    
    <content type="html"><![CDATA[<p> 批量发送消息可提高传递小消息的性能。同时也需要满足以下特征</p><ul><li>批量消息要求必要具有同一<code>topic</code>、相同消息配置</li><li><code>不支持延时消息</code></li><li>建议一个批量消息最好不要超过1MB大小<a id="more"></a><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4></li></ul><p>小于1MB</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String topic = <span class="string">"BatchTest"</span>;</span><br><span class="line">List&lt;Message&gt; messages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"Order1"</span>, <span class="string">"Hello world 0"</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"Order2"</span>, <span class="string">"Hello world 1"</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"Order3"</span>, <span class="string">"Hello world 2"</span>.getBytes()));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">producer.send(messages);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大于1MB也可以使用分割消息的方式进行多次批量发送。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 批量发送消息可提高传递小消息的性能。同时也需要满足以下特征&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;批量消息要求必要具有同一&lt;code&gt;topic&lt;/code&gt;、相同消息配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;不支持延时消息&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;建议一个批量消息最好不要超过1MB大小
    
    </summary>
    
      <category term="技术" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="rocketmq" scheme="https://blog.gitee.io/categories/%E6%8A%80%E6%9C%AF/rocketmq/"/>
    
    
      <category term="rocketmq" scheme="https://blog.gitee.io/tags/rocketmq/"/>
    
  </entry>
  
</feed>
